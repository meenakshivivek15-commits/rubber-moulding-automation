"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = sleep;
exports.longSleep = longSleep;
exports.retry = retry;
exports.retryInterval = retryInterval;
exports.asyncmap = asyncmap;
exports.asyncfilter = asyncfilter;
exports.waitForCondition = waitForCondition;
const LONG_SLEEP_THRESHOLD = 5000; // anything over 5000ms will turn into a spin
/**
 * An async/await version of setTimeout
 * @param ms - The number of milliseconds to wait
 */
async function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Sometimes `Promise.delay` or `setTimeout` are inaccurate for large wait
 * times. To safely wait for these long times (e.g. in the 5+ minute range), you
 * can use `longSleep`.
 *
 * You can also pass a `progressCb` option which is a callback function that
 * receives an object with the properties `elapsedMs`, `timeLeft`, and
 * `progress`. This will be called on every wait interval so you can do your
 * wait logging or whatever.
 * @param ms - The number of milliseconds to wait
 * @param options - Options for controlling the long sleep behavior
 */
async function longSleep(ms, { thresholdMs = LONG_SLEEP_THRESHOLD, intervalMs = 1000, progressCb = null } = {}) {
    if (ms < thresholdMs) {
        return await sleep(ms);
    }
    const endAt = Date.now() + ms;
    let timeLeft;
    let elapsedMs = 0;
    do {
        const pre = Date.now();
        await sleep(intervalMs);
        const post = Date.now();
        timeLeft = endAt - post;
        elapsedMs = elapsedMs + (post - pre);
        if (typeof progressCb === 'function') {
            progressCb({ elapsedMs, timeLeft, progress: elapsedMs / ms });
        }
    } while (timeLeft > 0);
}
/**
 * An async/await way of running a method until it doesn't throw an error
 * @param times - The maximum number of times to retry the function
 * @param fn - The async function to retry
 * @param args - Arguments to pass to the function
 */
async function retry(times, fn, ...args) {
    let tries = 0;
    let done = false;
    let res = null;
    while (!done && tries < times) {
        tries++;
        try {
            res = await fn(...args);
            done = true;
        }
        catch (err) {
            if (tries >= times) {
                throw err;
            }
        }
    }
    return res;
}
/**
 * You can also use `retryInterval` to add a sleep in between retries. This can
 * be useful if you want to throttle how fast we retry.
 * @param times - The maximum number of times to retry the function
 * @param sleepMs - The number of milliseconds to wait between retries
 * @param fn - The async function to retry
 * @param args - Arguments to pass to the function
 */
async function retryInterval(times, sleepMs, fn, ...args) {
    let count = 0;
    const wrapped = async () => {
        count++;
        let res;
        try {
            res = await fn(...args);
        }
        catch (e) {
            // do not pause when finished the last retry
            if (count !== times) {
                await sleep(sleepMs);
            }
            throw e;
        }
        return res;
    };
    return await retry(times, wrapped);
}
/**
 * Similar to `Array.prototype.map`; runs in serial or parallel
 * @param coll - The collection to map over
 * @param mapper - The function to apply to each element
 * @param runInParallel - Whether to run operations in parallel (default: true)
 */
async function asyncmap(coll, mapper, runInParallel = true) {
    if (runInParallel) {
        return Promise.all(coll.map(mapper));
    }
    const newColl = [];
    for (const item of coll) {
        newColl.push(await mapper(item));
    }
    return newColl;
}
/**
 * Similar to `Array.prototype.filter`
 * @param coll - The collection to filter
 * @param filter - The function to test each element
 * @param runInParallel - Whether to run operations in parallel (default: true)
 */
async function asyncfilter(coll, filter, runInParallel = true) {
    const newColl = [];
    if (runInParallel) {
        const bools = await Promise.all(coll.map(filter));
        for (let i = 0; i < coll.length; i++) {
            if (bools[i]) {
                newColl.push(coll[i]);
            }
        }
    }
    else {
        for (const item of coll) {
            if (await filter(item)) {
                newColl.push(item);
            }
        }
    }
    return newColl;
}
/**
 * Takes a condition (a function returning a boolean or boolean promise), and
 * waits until the condition is true.
 *
 * Throws a `/Condition unmet/` error if the condition has not been satisfied
 * within the allocated time, unless an error is provided in the options, as the
 * `error` property, which is either thrown itself, or used as the message.
 *
 * The condition result is returned if it is not falsy. If the condition throws an
 * error then this exception will be immediately passed through.
 *
 * The default options are: `{ waitMs: 5000, intervalMs: 500 }`
 * @param condFn - The condition function to evaluate
 * @param options - Options for controlling the wait behavior
 */
async function waitForCondition(condFn, options = {}) {
    const opts = {
        ...options,
        waitMs: typeof options.waitMs === 'number' ? options.waitMs : 5000,
        intervalMs: typeof options.intervalMs === 'number' ? options.intervalMs : 500,
    };
    const debug = opts.logger ? opts.logger.debug.bind(opts.logger) : () => undefined;
    const error = opts.error;
    const begunAt = Date.now();
    const endAt = begunAt + opts.waitMs;
    const spin = async function spin() {
        const result = await condFn();
        if (result) {
            return result;
        }
        const now = Date.now();
        const waited = now - begunAt;
        const remainingTime = endAt - now;
        if (now < endAt) {
            debug(`Waited for ${waited} ms so far`);
            await sleep(Math.min(opts.intervalMs, remainingTime));
            return await spin();
        }
        // if there is an error option, it is either a string message or an error itself
        if (error) {
            throw typeof error === 'string' ? new Error(error) : error;
        }
        throw new Error(`Condition unmet after ${waited} ms. Timing out.`);
    };
    return await spin();
}
//# sourceMappingURL=asyncbox.js.map