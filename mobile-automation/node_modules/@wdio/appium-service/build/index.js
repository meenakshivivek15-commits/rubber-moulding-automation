// src/launcher.ts
import os from "node:os";
import fs3 from "node:fs";
import fsp from "node:fs/promises";
import url from "node:url";
import path5 from "node:path";
import { spawn } from "node:child_process";
import { promisify } from "node:util";
import logger9 from "@wdio/logger";
import getPort from "get-port";
import { resolve as resolve2 } from "import-meta-resolve";
import { isCloudCapability } from "@wdio/config";
import { SevereServiceError as SevereServiceError3 } from "webdriverio";
import { isAppiumCapability } from "@wdio/utils";

// src/utils.ts
import { basename, join, resolve } from "node:path";
import { kebabCase } from "change-case";
var FILE_EXTENSION_REGEX = /\.[0-9a-z]+$/i;
function getFilePath(filePath, defaultFilename) {
  let absolutePath = resolve(filePath);
  if (!FILE_EXTENSION_REGEX.test(basename(absolutePath))) {
    absolutePath = join(absolutePath, defaultFilename);
  }
  return absolutePath;
}
function formatCliArgs(args) {
  const cliArgs = [];
  for (const key in args) {
    const value = args[key];
    if (typeof value === "boolean" && !value || value === null) {
      continue;
    }
    if (key === "chromedriver_autodownload") {
      cliArgs.push(key);
      continue;
    }
    cliArgs.push(`--${kebabCase(key)}`);
    if (typeof value !== "boolean") {
      cliArgs.push(sanitizeCliOptionValue(value));
    }
  }
  return cliArgs;
}
function sanitizeCliOptionValue(value) {
  const valueString = typeof value === "object" ? JSON.stringify(value) : String(value);
  return /\s/.test(valueString) ? `'${valueString}'` : valueString;
}

// src/launcher.ts
import treeKill from "tree-kill";

// src/mobileSelectorPerformanceOptimizer/aggregator.ts
import fs2 from "node:fs";
import path4 from "node:path";
import { SevereServiceError as SevereServiceError2 } from "webdriverio";

// src/mobileSelectorPerformanceOptimizer/mspo-store.ts
var currentSuiteName;
var currentTestFile;
var currentTestName;
var currentDeviceName;
var performanceData = [];
function setCurrentSuiteName(suiteName) {
  currentSuiteName = suiteName;
}
function getCurrentSuiteName() {
  return currentSuiteName;
}
function setCurrentTestFile(testFile) {
  currentTestFile = testFile;
}
function getCurrentTestFile() {
  return currentTestFile;
}
function setCurrentTestName(testName) {
  currentTestName = testName;
}
function getCurrentTestName() {
  return currentTestName;
}
function setCurrentDeviceName(deviceName) {
  currentDeviceName = deviceName;
}
function getCurrentDeviceName() {
  return currentDeviceName;
}
function addPerformanceData(data) {
  performanceData.push(data);
}
function getPerformanceData() {
  return performanceData;
}

// src/mobileSelectorPerformanceOptimizer/markdown-formatter.ts
import path3 from "node:path";

// src/mobileSelectorPerformanceOptimizer/utils/constants.ts
var LOG_PREFIX = "Mobile Selector Performance";
var SINGLE_ELEMENT_COMMANDS = ["$", "custom$"];
var MULTIPLE_ELEMENT_COMMANDS = ["$$", "custom$$"];
var USER_COMMANDS = [...SINGLE_ELEMENT_COMMANDS, ...MULTIPLE_ELEMENT_COMMANDS];
var REPORT_INDENT_SUMMARY = "   ";
var REPORT_INDENT_FILE = "   ";
var REPORT_INDENT_SUITE = "      ";
var REPORT_INDENT_SELECTOR = "            ";

// src/mobileSelectorPerformanceOptimizer/utils/selector-location.ts
import path from "node:path";
import fs from "node:fs";
import logger from "@wdio/logger";

// src/mobileSelectorPerformanceOptimizer/utils/selector-utils.ts
function extractSelectorFromArgs(args) {
  if (!args || args.length === 0) {
    return null;
  }
  const firstArg = args[0];
  if (typeof firstArg === "string") {
    return firstArg;
  }
  if (typeof firstArg === "object" && firstArg !== null) {
    try {
      return JSON.stringify(firstArg);
    } catch {
      return String(firstArg);
    }
  }
  return String(firstArg);
}
function isXPathSelector(selector) {
  if (typeof selector !== "string") {
    return false;
  }
  if (selector.startsWith("/") || selector.startsWith("../") || selector.startsWith("./") || selector.startsWith("*/")) {
    return true;
  }
  if (selector.startsWith("(")) {
    if (selector.startsWith("(:")) {
      return false;
    }
    return selector.includes("/") || selector.includes("@");
  }
  return false;
}
function parseOptimizedSelector(optimizedSelector) {
  if (optimizedSelector.startsWith("~")) {
    return {
      using: "accessibility id",
      value: optimizedSelector.substring(1)
    };
  }
  if (optimizedSelector.startsWith("-ios predicate string:")) {
    return {
      using: "-ios predicate string",
      value: optimizedSelector.substring("-ios predicate string:".length)
    };
  }
  if (optimizedSelector.startsWith("-ios class chain:")) {
    return {
      using: "-ios class chain",
      value: optimizedSelector.substring("-ios class chain:".length)
    };
  }
  return null;
}

// src/mobileSelectorPerformanceOptimizer/utils/selector-location.ts
var log = logger("@wdio/appium-service:selector-optimizer");
function findSelectorInFile(filePath, selector) {
  try {
    if (!fs.existsSync(filePath)) {
      return void 0;
    }
    const content = fs.readFileSync(filePath, "utf-8");
    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes(selector) || line.includes(`'${selector}'`) || line.includes(`"${selector}"`) || line.includes(`\`${selector}\``)) {
        return i + 1;
      }
    }
    return void 0;
  } catch {
    return void 0;
  }
}
function findPotentialPageObjects(testFile) {
  const testDir = path.dirname(testFile);
  const testBasename = path.basename(testFile);
  const ext = path.extname(testFile);
  const baseName = testBasename.replace(/\.(spec|test|e2e)/, "").replace(ext, "");
  const potentialFiles = [];
  const pageObjectDirs = ["pageobjects", "pageObjects", "page-objects", "pages", "page_objects"];
  let currentDir = testDir;
  for (let i = 0; i < 5; i++) {
    for (const poDir of pageObjectDirs) {
      const pageObjectDir = path.join(currentDir, poDir);
      if (fs.existsSync(pageObjectDir)) {
        const patterns = [
          `${baseName}.page${ext}`,
          `${baseName}.po${ext}`,
          `${baseName}Page${ext}`,
          `${baseName}${ext}`
        ];
        for (const pattern of patterns) {
          const fullPath = path.join(pageObjectDir, pattern);
          if (fs.existsSync(fullPath)) {
            potentialFiles.push(fullPath);
          }
        }
      }
    }
    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
  }
  return potentialFiles;
}
function findFilesInDirectory(dirPath, maxDepth = 5, currentDepth = 0) {
  const files = [];
  if (currentDepth >= maxDepth) {
    return files;
  }
  try {
    if (!fs.existsSync(dirPath) || !fs.statSync(dirPath).isDirectory()) {
      return files;
    }
    const entries = fs.readdirSync(dirPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dirPath, entry.name);
      if (entry.isDirectory()) {
        if (entry.name === "node_modules" || entry.name.startsWith(".")) {
          continue;
        }
        files.push(...findFilesInDirectory(fullPath, maxDepth, currentDepth + 1));
      } else if (entry.isFile() && /\.(js|ts|jsx|tsx)$/.test(entry.name)) {
        files.push(fullPath);
      }
    }
  } catch {
  }
  return files;
}
function findPageObjectFilesFromConfig(pageObjectPaths) {
  const files = [];
  for (const configPath of pageObjectPaths) {
    try {
      const resolvedPath = path.isAbsolute(configPath) ? configPath : path.resolve(process.cwd(), configPath);
      const stat = fs.statSync(resolvedPath);
      if (stat.isDirectory()) {
        files.push(...findFilesInDirectory(resolvedPath));
      } else if (stat.isFile() && /\.(js|ts|jsx|tsx)$/.test(resolvedPath)) {
        files.push(resolvedPath);
      }
    } catch {
    }
  }
  return files;
}
function findSelectorLocation(testFile, selector, pageObjectPaths) {
  if (!testFile || !selector) {
    log.debug("[Selector Location] No test file or selector provided");
    return [];
  }
  if (!isXPathSelector(selector)) {
    log.debug(`[Selector Location] Skipping non-XPath selector: ${selector}`);
    return [];
  }
  try {
    const locations = [];
    log.debug(`[Selector Location] Searching for XPath selector: ${selector}`);
    log.debug(`[Selector Location] Starting with test file: ${testFile}`);
    const testFileLine = findSelectorInFile(testFile, selector);
    if (testFileLine) {
      log.debug(`[Selector Location] Found in test file at line ${testFileLine}`);
      locations.push({
        file: testFile,
        line: testFileLine,
        isPageObject: false
      });
    }
    log.debug("[Selector Location] Searching page objects...");
    const pageObjectFiles = pageObjectPaths && pageObjectPaths.length > 0 ? findPageObjectFilesFromConfig(pageObjectPaths) : findPotentialPageObjects(testFile);
    if (pageObjectPaths && pageObjectPaths.length > 0) {
      log.debug("[Selector Location] Using configured page object paths:");
      pageObjectPaths.forEach((p) => {
        log.debug(`[Selector Location]   - ${p}`);
      });
    }
    if (pageObjectFiles.length > 0) {
      log.debug(`[Selector Location] Found ${pageObjectFiles.length} page object file(s) to search`);
    } else {
      log.debug("[Selector Location] No page object files found");
    }
    for (const pageObjectFile of pageObjectFiles) {
      const pageObjectLine = findSelectorInFile(pageObjectFile, selector);
      if (pageObjectLine) {
        log.debug(`[Selector Location] Found in page object at ${pageObjectFile}:${pageObjectLine}`);
        locations.push({
          file: pageObjectFile,
          line: pageObjectLine,
          isPageObject: true
        });
      }
    }
    if (locations.length === 0) {
      log.debug("[Selector Location] Selector not found in test file or page objects");
    } else {
      log.debug(`[Selector Location] Found ${locations.length} location(s)`);
    }
    return locations;
  } catch (error) {
    log.debug(`[Selector Location] Error: ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

// src/mobileSelectorPerformanceOptimizer/utils/browser-utils.ts
import logger2 from "@wdio/logger";
var log2 = logger2("@wdio/appium-service:selector-optimizer");
function isNativeContext(browser) {
  if (!browser) {
    return false;
  }
  try {
    const browserWithNativeContext = browser;
    if ("instances" in browser && Array.isArray(browser.instances)) {
      log2.warn("Mobile Selector Performance Optimizer does not support MultiRemote sessions yet. Feature disabled for this session.");
      return false;
    }
    return browserWithNativeContext.isNativeContext === true;
  } catch {
    return false;
  }
}

// src/mobileSelectorPerformanceOptimizer/utils/timing.ts
function getHighResTime() {
  return performance.now();
}

// src/mobileSelectorPerformanceOptimizer/utils/selector-testing.ts
import logger3 from "@wdio/logger";
var log3 = logger3("@wdio/appium-service:selector-optimizer");
async function extractMatchingElementsFromPageSource(browser, using, value) {
  try {
    const browserWithPageSource = browser;
    const pageSource = await browserWithPageSource.getPageSource();
    if (!pageSource || typeof pageSource !== "string") {
      return [];
    }
    const matchingElements = [];
    if (using === "-ios predicate string") {
      const typeMatch = value.match(/type\s*==\s*'([^']+)'/);
      const elementType = typeMatch ? typeMatch[1] : null;
      const conditions = [];
      const attrPattern = /(\w+)\s*==\s*'([^']+)'/g;
      let attrMatch;
      while ((attrMatch = attrPattern.exec(value)) !== null) {
        if (attrMatch[1] !== "type") {
          conditions.push({ attr: attrMatch[1], value: attrMatch[2] });
        }
      }
      if (!elementType) {
        return [];
      }
      const elementPattern = new RegExp(`<${elementType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}([^>]*)>`, "gi");
      let match;
      while ((match = elementPattern.exec(pageSource)) !== null) {
        const attrs = match[1] || "";
        let matches = true;
        for (const condition of conditions) {
          const attrPattern2 = new RegExp(`${condition.attr}="([^"]*)"`, "i");
          const attrMatch2 = attrs.match(attrPattern2);
          if (!attrMatch2 || attrMatch2[1] !== condition.value) {
            matches = false;
            break;
          }
        }
        if (matches) {
          matchingElements.push(match[0]);
        }
      }
    } else if (using === "-ios class chain") {
      const typeMatch = value.match(/^\*\*\/(\w+)/);
      const elementType = typeMatch ? typeMatch[1] : null;
      if (elementType) {
        const predicateMatch = value.match(/\[`([^`]+)`\]/);
        const conditions = [];
        if (predicateMatch) {
          const predicateContent = predicateMatch[1];
          const attrPattern = /(\w+)\s*==\s*"([^"]+)"/g;
          let attrMatch;
          while ((attrMatch = attrPattern.exec(predicateContent)) !== null) {
            conditions.push({ attr: attrMatch[1], value: attrMatch[2] });
          }
        }
        const elementPattern = new RegExp(`<${elementType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}([^>]*)>`, "gi");
        let match;
        while ((match = elementPattern.exec(pageSource)) !== null) {
          const attrs = match[1] || "";
          let matches = true;
          for (const condition of conditions) {
            const attrPattern = new RegExp(`${condition.attr}="([^"]*)"`, "i");
            const attrMatch = attrs.match(attrPattern);
            if (!attrMatch || attrMatch[1] !== condition.value) {
              matches = false;
              break;
            }
          }
          if (matches) {
            matchingElements.push(match[0]);
          }
        }
      }
    }
    return matchingElements;
  } catch {
    return [];
  }
}
async function testOptimizedSelector(browser, using, value, isMultiple, debug = false) {
  try {
    if (debug) {
      log3.debug(`[${LOG_PREFIX}: Debug] Step 1: Preparing to call findElement${isMultiple ? "s" : ""}`);
      log3.debug(`[${LOG_PREFIX}: Debug] Step 1.1: Using strategy: "${using}"`);
      log3.debug(`[${LOG_PREFIX}: Debug] Step 1.2: Selector value: "${value}"`);
      log3.debug(`[${LOG_PREFIX}: Debug] Step 1.3: Multiple elements: ${isMultiple}`);
    }
    const startTime = getHighResTime();
    const browserWithProtocol = browser;
    if (debug) {
      log3.debug(`[${LOG_PREFIX}: Debug] Step 2: Executing findElement${isMultiple ? "s" : ""}(${JSON.stringify(using)}, ${JSON.stringify(value)})`);
    }
    let elementRefs = [];
    let duration;
    if (isMultiple) {
      const result = await browserWithProtocol.findElements(using, value);
      duration = getHighResTime() - startTime;
      elementRefs = Array.isArray(result) ? result : [];
      if (debug) {
        log3.debug(`[${LOG_PREFIX}: Debug] Step 3: findElements() completed`);
        log3.debug(`[${LOG_PREFIX}: Debug] Step 3.1: Found ${elementRefs.length} element(s)`);
        if (elementRefs.length > 0) {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.2: Element reference(s): ${JSON.stringify(elementRefs)}`);
        } else {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.2: No elements found - selector may not match any elements`);
        }
        log3.debug(`[${LOG_PREFIX}: Debug] Step 3.3: Execution time: ${duration.toFixed(2)}ms`);
      }
    } else {
      const result = await browserWithProtocol.findElement(using, value);
      duration = getHighResTime() - startTime;
      const isError = result && typeof result === "object" && "error" in result;
      const isValidElement = result && !isError && ("ELEMENT" in result || "element-6066-11e4-a52e-4f735466cecf" in result);
      elementRefs = isValidElement ? [result] : [];
      if (debug) {
        log3.debug(`[${LOG_PREFIX}: Debug] Step 3: findElement() completed`);
        if (isError) {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.1: Element NOT found - error returned`);
          const errorMsg = result.message || result.error || "Unknown error";
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.2: Error details: ${errorMsg}`);
        } else if (isValidElement) {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.1: Element found successfully`);
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.2: Element reference: ${JSON.stringify(result)}`);
        } else {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 3.1: No element found - selector may not match any element`);
        }
        log3.debug(`[${LOG_PREFIX}: Debug] Step 3.3: Execution time: ${duration.toFixed(2)}ms`);
      }
    }
    if (debug) {
      if (elementRefs.length > 0) {
        log3.debug(`[${LOG_PREFIX}: Debug] Step 4: Verification successful - selector is valid and found element(s)`);
      }
      if (elementRefs.length === 0) {
        log3.debug(`[${LOG_PREFIX}: Debug] Step 4: Verification failed - selector did not find any element(s)`);
        log3.debug(`[${LOG_PREFIX}: Debug] Step 5: Collecting fresh page source to investigate...`);
        log3.debug(`[${LOG_PREFIX}: Debug] Step 5.0: Searching for elements matching: ${using}="${value}"`);
        const matchingElements = await extractMatchingElementsFromPageSource(browser, using, value);
        if (matchingElements.length > 0) {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 5.1: Found ${matchingElements.length} matching element(s) in fresh page source:`);
          matchingElements.forEach((element, index) => {
            const truncated = element.length > 200 ? element.substring(0, 200) + "..." : element;
            log3.debug(`[${LOG_PREFIX}: Debug] Step 5.1.${index + 1}: ${truncated}`);
          });
          log3.debug(`[${LOG_PREFIX}: Debug] Step 5.2: Retrying selector with fresh page source state...`);
          const retryStartTime = getHighResTime();
          try {
            if (isMultiple) {
              const retryResult = await browserWithProtocol.findElements(using, value);
              const retryDuration = getHighResTime() - retryStartTime;
              const retryElementRefs = Array.isArray(retryResult) ? retryResult : [];
              if (retryElementRefs.length > 0) {
                log3.debug(`[${LOG_PREFIX}: Debug] Step 5.3: Retry successful! Found ${retryElementRefs.length} element(s) in ${retryDuration.toFixed(2)}ms`);
                return { elementRefs: retryElementRefs, duration: retryDuration };
              }
              log3.debug(`[${LOG_PREFIX}: Debug] Step 5.3: Retry failed - still no elements found (${retryDuration.toFixed(2)}ms)`);
            } else {
              const retryResult = await browserWithProtocol.findElement(using, value);
              const retryDuration = getHighResTime() - retryStartTime;
              const isError = retryResult && typeof retryResult === "object" && "error" in retryResult;
              const isValidElement = retryResult && !isError && ("ELEMENT" in retryResult || "element-6066-11e4-a52e-4f735466cecf" in retryResult);
              const retryElementRefs = isValidElement ? [retryResult] : [];
              if (retryElementRefs.length > 0) {
                log3.debug(`[${LOG_PREFIX}: Debug] Step 5.3: Retry successful! Found element in ${retryDuration.toFixed(2)}ms`);
                return { elementRefs: retryElementRefs, duration: retryDuration };
              }
              const errorMsg = isError ? retryResult.message || retryResult.error || "Unknown error" : "No element found";
              log3.debug(`[${LOG_PREFIX}: Debug] Step 5.3: Retry failed - ${errorMsg} (${retryDuration.toFixed(2)}ms)`);
            }
          } catch (retryError) {
            const retryDuration = getHighResTime() - retryStartTime;
            log3.debug(`[${LOG_PREFIX}: Debug] Step 5.3: Retry threw error: ${retryError instanceof Error ? retryError.message : String(retryError)} (${retryDuration.toFixed(2)}ms)`);
          }
        } else {
          log3.debug(`[${LOG_PREFIX}: Debug] Step 5.1: No matching elements found in fresh page source - element may have disappeared`);
        }
      }
    }
    return { elementRefs, duration };
  } catch (error) {
    if (debug) {
      log3.debug(`[${LOG_PREFIX}: Debug] Step 3: findElement${isMultiple ? "s" : ""}() threw an error`);
      log3.debug(`[${LOG_PREFIX}: Debug] Step 3.1: Error: ${error instanceof Error ? error.message : String(error)}`);
      log3.debug(`[${LOG_PREFIX}: Debug] Step 4: Verification failed - selector execution error`);
    }
    return null;
  }
}

// src/mobileSelectorPerformanceOptimizer/utils/optimization.ts
import logger7 from "@wdio/logger";

// src/mobileSelectorPerformanceOptimizer/utils/xpath-converter.ts
import logger6 from "@wdio/logger";

// src/mobileSelectorPerformanceOptimizer/utils/xpath-constants.ts
var UNMAPPABLE_XPATH_AXES = [
  { pattern: /ancestor::/i, name: "ancestor axis" },
  { pattern: /ancestor-or-self::/i, name: "ancestor-or-self axis" },
  { pattern: /following-sibling::/i, name: "following-sibling axis" },
  { pattern: /preceding-sibling::/i, name: "preceding-sibling axis" },
  { pattern: /following::/i, name: "following axis" },
  { pattern: /preceding::/i, name: "preceding axis" },
  { pattern: /parent::/i, name: "parent axis" },
  { pattern: /\/\.\.(?:\/|$|\[|\))/, name: "parent axis" }
];
var UNMAPPABLE_XPATH_FUNCTIONS = [
  { pattern: /normalize-space\(/i, name: "normalize-space() function" },
  { pattern: /position\(\)/i, name: "position() function" },
  { pattern: /count\(/i, name: "count() function" }
];
var ATTRIBUTE_PRIORITY = ["name", "label", "value", "enabled", "visible", "accessible", "hittable"];
var MEANINGFUL_ATTRIBUTES = ["name", "label", "value"];
var BOOLEAN_ATTRIBUTES = ["enabled", "visible", "accessible", "hittable"];

// src/mobileSelectorPerformanceOptimizer/utils/xpath-detection.ts
function detectUnmappableXPathFeatures(xpath2) {
  const unmappableFeatures = [];
  for (const axis of UNMAPPABLE_XPATH_AXES) {
    if (axis.pattern.test(xpath2)) {
      unmappableFeatures.push(axis.name);
    }
  }
  for (const func of UNMAPPABLE_XPATH_FUNCTIONS) {
    if (func.pattern.test(xpath2)) {
      unmappableFeatures.push(func.name);
    }
  }
  if (/substring\([^)]+\)/.test(xpath2)) {
    const textSubstringMatch = xpath2.match(/substring\(text\(\),\s*1\s*,\s*\d+\)/i);
    const attrSubstringMatch = xpath2.match(/substring\(@\w+,\s*1\s*,\s*\d+\)/i);
    if (!textSubstringMatch && !attrSubstringMatch) {
      const substringMatch = xpath2.match(/substring\([^,]+,\s*(\d+)/i);
      if (substringMatch && substringMatch[1] !== "1") {
        unmappableFeatures.push("complex substring() function (not starting at position 1)");
      }
    }
  }
  if (containsUnionOperator(xpath2)) {
    unmappableFeatures.push("union operator (|)");
  }
  return unmappableFeatures;
}
function containsUnionOperator(xpath2) {
  let depth = 0;
  let inSingleQuote = false;
  let inDoubleQuote = false;
  for (let i = 0; i < xpath2.length; i++) {
    const char = xpath2[i];
    if (char === "'" && !inDoubleQuote) {
      inSingleQuote = !inSingleQuote;
    } else if (char === '"' && !inSingleQuote) {
      inDoubleQuote = !inDoubleQuote;
    } else if (!inSingleQuote && !inDoubleQuote) {
      if (char === "[" || char === "(") {
        depth++;
      } else if (char === "]" || char === ")") {
        depth--;
      } else if (char === "|" && depth === 0) {
        return true;
      }
    }
  }
  return false;
}

// src/mobileSelectorPerformanceOptimizer/utils/xpath-page-source.ts
import logger4 from "@wdio/logger";
var log4 = logger4("@wdio/appium-service:selector-optimizer");
function isSelectorUniqueInPageSource(selector, pageSource) {
  try {
    if (selector.startsWith("~")) {
      return isAccessibilityIdUnique(selector.substring(1), pageSource);
    } else if (selector.startsWith("-ios predicate string:")) {
      const predicateString = selector.substring("-ios predicate string:".length);
      return countMatchingElementsByPredicate(predicateString, pageSource) === 1;
    } else if (selector.startsWith("-ios class chain:")) {
      const chainString = selector.substring("-ios class chain:".length);
      return countMatchingElementsByClassChain(chainString, pageSource) === 1;
    }
    return false;
  } catch (error) {
    log4.debug(`Selector uniqueness check failed: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}
function isAccessibilityIdUnique(value, pageSource) {
  const escapedValue = value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const namePattern = new RegExp(`<\\w+[^>]*\\s+name="${escapedValue}"[^>]*>`, "gi");
  const labelPattern = new RegExp(`<\\w+[^>]*\\s+label="${escapedValue}"[^>]*>`, "gi");
  const nameMatches = pageSource.match(namePattern) || [];
  const labelMatches = pageSource.match(labelPattern) || [];
  const allMatches = /* @__PURE__ */ new Set([...nameMatches, ...labelMatches]);
  return allMatches.size === 1;
}
function countMatchingElementsByPredicate(predicateString, pageSource) {
  const conditions = parsePredicateConditions(predicateString);
  const typeMatch = predicateString.match(/type\s*==\s*'([^']+)'/);
  const elementType = typeMatch ? typeMatch[1] : null;
  const elementPattern = elementType ? new RegExp(`<${elementType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}([^>]*)>`, "gi") : /<(\w+)([^>]*)>/gi;
  let match;
  let count = 0;
  while ((match = elementPattern.exec(pageSource)) !== null) {
    const attrs = match[1] || match[2] || "";
    if (elementType && !match[0].includes(`<${elementType}`)) {
      continue;
    }
    if (matchesPredicateConditions(attrs, conditions)) {
      count++;
    }
  }
  return count;
}
function parsePredicateConditions(predicateString) {
  const conditions = [];
  const attrPattern = /(\w+)\s*==\s*'([^']+)'/g;
  let attrMatch;
  while ((attrMatch = attrPattern.exec(predicateString)) !== null) {
    if (attrMatch[1] !== "type") {
      conditions.push({ attr: attrMatch[1], op: "==", value: attrMatch[2] });
    }
  }
  return conditions;
}
function matchesPredicateConditions(attrs, conditions) {
  for (const condition of conditions) {
    const attrPattern = new RegExp(`${condition.attr}="([^"]*)"`, "i");
    const attrMatch = attrs.match(attrPattern);
    if (!attrMatch || attrMatch[1] !== condition.value) {
      return false;
    }
  }
  return true;
}
function countMatchingElementsByClassChain(chainString, pageSource) {
  const typeMatch = chainString.match(/^\*\*\/(\w+)/);
  const elementType = typeMatch ? typeMatch[1] : null;
  if (!elementType) {
    return 0;
  }
  const predicateMatch = chainString.match(/\[`([^`]+)`\]/);
  const conditions = [];
  if (predicateMatch) {
    const predicateContent = predicateMatch[1];
    const attrPattern = /(\w+)\s*==\s*"([^"]+)"/g;
    let attrMatch;
    while ((attrMatch = attrPattern.exec(predicateContent)) !== null) {
      conditions.push({ attr: attrMatch[1], op: "==", value: attrMatch[2] });
    }
  }
  const elementPattern = new RegExp(`<${elementType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}([^>]*)>`, "gi");
  let match;
  let count = 0;
  while ((match = elementPattern.exec(pageSource)) !== null) {
    const attrs = match[1] || "";
    let matches = true;
    for (const condition of conditions) {
      const attrPattern = new RegExp(`${condition.attr}="([^"]*)"`, "i");
      const attrMatch = attrs.match(attrPattern);
      if (!attrMatch || attrMatch[1] !== condition.value) {
        matches = false;
        break;
      }
    }
    if (matches) {
      count++;
    }
  }
  return count;
}

// src/mobileSelectorPerformanceOptimizer/utils/xpath-selector-builder.ts
function buildSelectorFromElementData(elementData, pageSource) {
  const { type, attributes } = elementData;
  const name = attributes.name || attributes.label;
  if (name) {
    const accessibilitySelector = `~${name}`;
    if (isSelectorUniqueInPageSource(accessibilitySelector, pageSource)) {
      return { selector: accessibilitySelector };
    }
  }
  if (type) {
    const predicateResult = buildUniquePredicateString(type, attributes, pageSource);
    if (predicateResult) {
      return predicateResult;
    }
  }
  if (type) {
    const classChainResult = buildUniqueClassChain(type, attributes, pageSource);
    if (classChainResult) {
      return classChainResult;
    }
  }
  return {
    selector: null,
    warning: "Could not generate a unique selector from element data. Multiple elements may match the suggested selector."
  };
}
function buildUniquePredicateString(type, attributes, pageSource) {
  const predicateParts = [`type == '${type}'`];
  let selector = `-ios predicate string:${predicateParts.join(" AND ")}`;
  if (isSelectorUniqueInPageSource(selector, pageSource)) {
    return { selector };
  }
  const name = attributes.name;
  const label = attributes.label;
  const nameEqualsLabel = name && label && name === label;
  for (const attr of MEANINGFUL_ATTRIBUTES) {
    if (attr === "label" && nameEqualsLabel) {
      continue;
    }
    if (attributes[attr] !== void 0) {
      const value = attributes[attr];
      if (typeof value === "string" && value.length > 0) {
        predicateParts.push(`${attr} == '${value}'`);
        selector = `-ios predicate string:${predicateParts.join(" AND ")}`;
        if (isSelectorUniqueInPageSource(selector, pageSource)) {
          return { selector };
        }
      }
    }
  }
  for (const attr of BOOLEAN_ATTRIBUTES) {
    if (attributes[attr] === "true") {
      predicateParts.push(`${attr} == 'true'`);
      selector = `-ios predicate string:${predicateParts.join(" AND ")}`;
      if (isSelectorUniqueInPageSource(selector, pageSource)) {
        return { selector };
      }
    }
  }
  const meaningfulOnlyParts = predicateParts.filter((part) => {
    const attr = part.split(" == ")[0];
    return !BOOLEAN_ATTRIBUTES.includes(attr);
  });
  if (meaningfulOnlyParts.length > 1) {
    return {
      selector: `-ios predicate string:${meaningfulOnlyParts.join(" AND ")}`,
      warning: "Selector may match multiple elements. Consider adding more specific attributes."
    };
  }
  if (predicateParts.length > 1) {
    return {
      selector: `-ios predicate string:${predicateParts.join(" AND ")}`,
      warning: "Selector may match multiple elements. Consider adding more specific attributes."
    };
  }
  return null;
}
function buildUniqueClassChain(type, attributes, pageSource) {
  const chain = `**/${type}`;
  const predicateParts = [];
  for (const attr of ATTRIBUTE_PRIORITY) {
    if (attributes[attr] !== void 0) {
      const value = attributes[attr];
      if (typeof value === "string" && value.length > 0) {
        predicateParts.push(`${attr} == "${value}"`);
        const selector = `-ios class chain:${chain}[\`${predicateParts.join(" AND ")}\`]`;
        if (isSelectorUniqueInPageSource(selector, pageSource)) {
          return { selector };
        }
      }
    }
  }
  if (predicateParts.length > 0) {
    return {
      selector: `-ios class chain:${chain}[\`${predicateParts.join(" AND ")}\`]`,
      warning: "Selector may match multiple elements. Consider adding more specific attributes."
    };
  }
  const basicSelector = `-ios class chain:${chain}`;
  if (isSelectorUniqueInPageSource(basicSelector, pageSource)) {
    return { selector: basicSelector };
  }
  return {
    selector: basicSelector,
    warning: "Selector may match multiple elements. Consider adding more specific attributes."
  };
}

// src/mobileSelectorPerformanceOptimizer/utils/xpath-page-source-executor.ts
import { DOMParser } from "@xmldom/xmldom";
import xpath from "xpath";
import logger5 from "@wdio/logger";
var log5 = logger5("@wdio/appium-service:selector-optimizer");
function executeXPathOnPageSource(xpathExpr, pageSource) {
  if (!pageSource || !xpathExpr) {
    return null;
  }
  try {
    const doc = new DOMParser().parseFromString(pageSource, "text/xml");
    const parseErrors = doc.getElementsByTagName("parsererror");
    if (parseErrors.length > 0) {
      log5.debug("XML parsing error in page source");
      return null;
    }
    const nodes = xpath.select(xpathExpr, doc);
    if (!nodes || !Array.isArray(nodes) || nodes.length === 0) {
      return [];
    }
    const elements = [];
    for (const node of nodes) {
      if (node && typeof node === "object" && "nodeName" in node && "attributes" in node) {
        const elementNode = node;
        const attributes = {};
        if (elementNode.attributes) {
          for (let i = 0; i < elementNode.attributes.length; i++) {
            const attr = elementNode.attributes[i];
            if (attr && attr.name && attr.value !== void 0) {
              attributes[attr.name] = attr.value;
            }
          }
        }
        elements.push({
          type: elementNode.nodeName,
          attributes
        });
      }
    }
    return elements;
  } catch (error) {
    log5.debug(`XPath execution failed: ${error instanceof Error ? error.message : String(error)}`);
    return null;
  }
}
function findElementByXPathWithFallback(xpathExpr, pageSource) {
  const elements = executeXPathOnPageSource(xpathExpr, pageSource);
  if (!elements || elements.length === 0) {
    return null;
  }
  return {
    element: elements[0],
    matchCount: elements.length
  };
}

// src/mobileSelectorPerformanceOptimizer/utils/xpath-converter.ts
var log6 = logger6("@wdio/appium-service:selector-optimizer");
async function convertXPathToOptimizedSelector(xpath2, options) {
  if (!xpath2 || typeof xpath2 !== "string") {
    return null;
  }
  const unmappableFeatures = detectUnmappableXPathFeatures(xpath2);
  const hasUnmappableFeatures = unmappableFeatures.length > 0;
  const unmappableWarning = hasUnmappableFeatures ? `XPath contains unmappable features: ${unmappableFeatures.join(", ")}.` : void 0;
  try {
    const browserWithPageSource = options.browser;
    const pageSource = await browserWithPageSource.getPageSource();
    if (!pageSource || typeof pageSource !== "string") {
      return {
        selector: null,
        warning: hasUnmappableFeatures ? `${unmappableWarning} Page source unavailable.` : "Page source unavailable."
      };
    }
    const result = findElementByXPathWithFallback(xpath2, pageSource);
    if (!result) {
      return {
        selector: null,
        warning: hasUnmappableFeatures ? `${unmappableWarning} Element not found in page source.` : "Element not found in page source."
      };
    }
    const { element, matchCount } = result;
    const selectorResult = buildSelectorFromElementData(element, pageSource);
    if (!selectorResult || !selectorResult.selector) {
      return {
        selector: null,
        warning: hasUnmappableFeatures ? `${unmappableWarning} Could not build selector from element attributes.` : "Could not build selector from element attributes."
      };
    }
    if (matchCount > 1) {
      return {
        selector: null,
        warning: `XPath matched ${matchCount} elements. The suggested selector may not be unique. You can use this selector but be aware it may match multiple elements.`,
        suggestion: selectorResult.selector
      };
    }
    return selectorResult;
  } catch (error) {
    log6.debug(`Page source analysis failed: ${error instanceof Error ? error.message : String(error)}`);
    return {
      selector: null,
      warning: hasUnmappableFeatures ? `${unmappableWarning} Page source analysis failed.` : "Page source analysis failed."
    };
  }
}

// src/mobileSelectorPerformanceOptimizer/utils/optimization.ts
var log7 = logger7("@wdio/appium-service:selector-optimizer");
async function findOptimizedSelector(xpath2, options) {
  log7.info(`[${LOG_PREFIX}: Step 2] Collecting page source for dynamic analysis...`);
  const pageSourceStartTime = getHighResTime();
  const result = await convertXPathToOptimizedSelector(xpath2, {
    browser: options.browser
  });
  const pageSourceDuration = getHighResTime() - pageSourceStartTime;
  log7.info(`[${LOG_PREFIX}: Step 2] Page source collected in ${pageSourceDuration.toFixed(2)}ms`);
  return result;
}

// src/mobileSelectorPerformanceOptimizer/utils/formatting.ts
import logger8 from "@wdio/logger";
var log8 = logger8("@wdio/appium-service:selector-optimizer");
function formatSelectorForDisplay(selector, maxLength = 100) {
  if (typeof selector === "string") {
    if (selector.length > maxLength) {
      return selector.substring(0, maxLength) + "...";
    }
    return selector;
  }
  return String(selector);
}
function formatSelectorLocations(locations) {
  if (locations.length === 0) {
    return "";
  }
  if (locations.length === 1) {
    const loc = locations[0];
    const fileDisplay = loc.isPageObject ? `${loc.file} (page object)` : loc.file;
    return ` at ${fileDisplay}:${loc.line}`;
  }
  const locationStrings = locations.map((loc) => {
    const fileDisplay = loc.isPageObject ? `${loc.file} (page object)` : loc.file;
    return `${fileDisplay}:${loc.line}`;
  });
  return ` at multiple locations: ${locationStrings.join(", ")}. Note: The selector was found in ${locations.length} files. Please verify which one is correct.`;
}
function logOptimizationConclusion(timeDifference, improvementPercent, originalSelector, optimizedSelector, locationInfo = "") {
  const formattedOriginal = formatSelectorForDisplay(originalSelector);
  const formattedOptimized = formatSelectorForDisplay(optimizedSelector);
  const quoteStyle = optimizedSelector.startsWith("-ios class chain:") ? "'" : '"';
  if (timeDifference > 0) {
    log8.info(`[${LOG_PREFIX}: Conclusion] Optimized selector is ${timeDifference.toFixed(2)}ms faster than XPath (${improvementPercent.toFixed(1)}% improvement)`);
    log8.info(`[${LOG_PREFIX}: Advice] Consider using the optimized selector ${quoteStyle}${formattedOptimized}${quoteStyle} for better performance${locationInfo ? locationInfo : ""}.`);
  } else if (timeDifference < 0) {
    log8.info(`[${LOG_PREFIX}: Conclusion] Optimized selector is ${Math.abs(timeDifference).toFixed(2)}ms slower than XPath`);
    log8.info(`[${LOG_PREFIX}: Advice] There is no improvement in performance, consider using the original selector '${formattedOriginal}' if performance is critical. If performance is not critical, you can use the optimized selector ${quoteStyle}${formattedOptimized}${quoteStyle} for better stability${locationInfo ? locationInfo : ""}.`);
  } else {
    log8.info(`[${LOG_PREFIX}: Conclusion] Optimized selector has the same performance as XPath`);
    log8.info(`[${LOG_PREFIX}: Advice] There is no improvement in performance, consider using the original selector '${formattedOriginal}' if performance is critical. If performance is not critical, you can use the optimized selector ${quoteStyle}${formattedOptimized}${quoteStyle} for better stability${locationInfo ? locationInfo : ""}.`);
  }
}

// src/mobileSelectorPerformanceOptimizer/utils/performance-data.ts
function createOptimizedSelectorData(testContext, originalSelector, originalDuration, optimizedSelector, optimizedDuration) {
  const timeDifference = originalDuration - optimizedDuration;
  const improvementPercent = originalDuration > 0 ? timeDifference / originalDuration * 100 : 0;
  return {
    testFile: testContext.testFile || "unknown",
    suiteName: testContext.suiteName,
    testName: testContext.testName,
    lineNumber: testContext.lineNumber,
    selectorFile: testContext.selectorFile,
    selector: originalSelector,
    selectorType: "xpath",
    duration: originalDuration,
    timestamp: Date.now(),
    deviceName: getCurrentDeviceName(),
    optimizedSelector,
    optimizedDuration,
    improvementMs: timeDifference,
    improvementPercent
  };
}
function storePerformanceData(timing, duration, testContext) {
  const data = {
    testFile: testContext.testFile || "unknown",
    suiteName: testContext.suiteName,
    testName: testContext.testName,
    lineNumber: testContext.lineNumber,
    selector: timing.selector,
    selectorType: timing.selectorType,
    duration,
    timestamp: Date.now(),
    deviceName: getCurrentDeviceName()
  };
  addPerformanceData(data);
}

// src/mobileSelectorPerformanceOptimizer/utils/command-timing.ts
function findMostRecentUnmatchedUserCommand(commandTimings) {
  return Array.from(commandTimings.entries()).filter(([_id, timing]) => timing.isUserCommand && !timing.selectorType).sort(([_idA, a], [_idB, b]) => b.startTime - a.startTime)[0];
}
function findMatchingInternalCommandTiming(commandTimings, formattedSelector, selectorType) {
  return Array.from(commandTimings.entries()).filter(
    ([_id, timing]) => !timing.isUserCommand && timing.formattedSelector === formattedSelector && timing.selectorType === selectorType
  ).sort(([_idA, a], [_idB, b]) => b.startTime - a.startTime)[0];
}

// src/mobileSelectorPerformanceOptimizer/utils/reporter.ts
import path2 from "node:path";
import { SevereServiceError } from "webdriverio";
function isReporterRegistered(reporters, reporterName) {
  return reporters.some((reporter) => {
    if (Array.isArray(reporter)) {
      const reporterClass = reporter[0];
      if (typeof reporterClass === "function") {
        return reporterClass.name === reporterName;
      }
      return false;
    }
    if (typeof reporter === "function") {
      return reporter.name === reporterName;
    }
    return false;
  });
}
function determineReportDirectory(reportPath, config, appiumServiceOptions) {
  let reportDir;
  if (reportPath) {
    reportDir = path2.isAbsolute(reportPath) ? reportPath : path2.join(process.cwd(), reportPath);
  } else if (config?.outputDir) {
    reportDir = path2.isAbsolute(config.outputDir) ? config.outputDir : path2.join(process.cwd(), config.outputDir);
  } else if (appiumServiceOptions?.logPath) {
    reportDir = path2.isAbsolute(appiumServiceOptions.logPath) ? appiumServiceOptions.logPath : path2.join(process.cwd(), appiumServiceOptions.logPath);
  } else if (appiumServiceOptions?.args?.log) {
    const logPath = appiumServiceOptions.args.log;
    reportDir = path2.isAbsolute(logPath) ? path2.dirname(logPath) : path2.join(process.cwd(), path2.dirname(logPath));
  }
  if (!reportDir) {
    throw new SevereServiceError(
      "Mobile Selector Performance Optimizer: JSON report cannot be created. Please provide one of the following:\n  1. reportPath in trackSelectorPerformance service options\n  2. outputDir in WebdriverIO config\n  3. logPath in Appium service options\n  4. log in Appium service args"
    );
  }
  return reportDir;
}

// src/mobileSelectorPerformanceOptimizer/markdown-formatter.ts
function countSelectorUsage(data) {
  const counts = /* @__PURE__ */ new Map();
  for (const entry of data) {
    const count = counts.get(entry.selector) || 0;
    counts.set(entry.selector, count + 1);
  }
  return counts;
}
function deduplicateSelectors(data, usageCounts) {
  const selectorMap = /* @__PURE__ */ new Map();
  for (const entry of data) {
    if (!entry.optimizedSelector || entry.improvementMs === void 0) {
      continue;
    }
    const existing = selectorMap.get(entry.selector);
    const current = {
      selector: entry.selector,
      optimizedSelector: entry.optimizedSelector,
      improvementMs: entry.improvementMs,
      improvementPercent: entry.improvementPercent || 0,
      lineNumber: entry.lineNumber,
      selectorFile: entry.selectorFile,
      testFile: entry.testFile,
      usageCount: usageCounts.get(entry.selector) || 1
    };
    if (!existing || Math.abs(current.improvementMs) > Math.abs(existing.improvementMs)) {
      if (existing && !current.selectorFile && existing.selectorFile) {
        current.selectorFile = existing.selectorFile;
        current.lineNumber = existing.lineNumber;
      }
      selectorMap.set(entry.selector, current);
    } else if (!existing.selectorFile && current.selectorFile) {
      existing.selectorFile = current.selectorFile;
      existing.lineNumber = current.lineNumber;
    }
  }
  return Array.from(selectorMap.values());
}
function groupByFile(optimizations) {
  const fileMap = /* @__PURE__ */ new Map();
  const workspaceWide = [];
  for (const opt of optimizations) {
    const filePath = opt.selectorFile;
    if (filePath && opt.lineNumber) {
      if (!fileMap.has(filePath)) {
        fileMap.set(filePath, []);
      }
      fileMap.get(filePath).push(opt);
    } else {
      workspaceWide.push(opt);
    }
  }
  const fileGroups = [];
  for (const [filePath, opts] of fileMap.entries()) {
    opts.sort((a, b) => (a.lineNumber || 0) - (b.lineNumber || 0));
    const totalSavingsMs = opts.reduce((sum, o) => sum + o.improvementMs, 0);
    const totalSavingsWithUsage = opts.reduce((sum, o) => sum + o.improvementMs * o.usageCount, 0);
    fileGroups.push({ filePath, optimizations: opts, totalSavingsMs, totalSavingsWithUsage });
  }
  fileGroups.sort((a, b) => b.totalSavingsWithUsage - a.totalSavingsWithUsage);
  workspaceWide.sort((a, b) => b.improvementMs * b.usageCount - a.improvementMs * a.usageCount);
  return { fileGroups, workspaceWide };
}
function escapeForTable(str) {
  return str.replace(/\\/g, "\\\\").replace(/\|/g, "\\|");
}
function getQuoteStyle(selector) {
  if (selector.startsWith("//") || selector.startsWith("/")) {
    return "'";
  }
  if (selector.startsWith("-ios class chain:")) {
    return "'";
  }
  return '"';
}
function formatSelector(selector) {
  const truncated = formatSelectorForDisplay(selector, 60);
  const quote = getQuoteStyle(selector);
  return `\`$(${quote}${escapeForTable(truncated)}${quote})\``;
}
function toRelativePath(filePath, projectRoot) {
  if (!projectRoot) {
    return filePath;
  }
  if (!path3.isAbsolute(filePath)) {
    return filePath;
  }
  return path3.relative(projectRoot, filePath);
}
function getFileName(filePath) {
  return path3.basename(filePath);
}
function formatFileLink(filePath, lineNumber, projectRoot) {
  const relativePath = toRelativePath(filePath, projectRoot);
  const fileName = getFileName(filePath);
  if (lineNumber) {
    return `[\`${fileName}:${lineNumber}\`](${relativePath}#L${lineNumber})`;
  }
  return `[\`${fileName}\`](${relativePath})`;
}
function formatLineLink(filePath, lineNumber, projectRoot) {
  if (!lineNumber) {
    return "L?:";
  }
  const relativePath = toRelativePath(filePath, projectRoot);
  return `[L${lineNumber}:](${relativePath}#L${lineNumber})`;
}
function formatTime(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
}
function formatDuration(ms) {
  if (ms < 1e3) {
    return `${ms.toFixed(0)}ms`;
  }
  const seconds = ms / 1e3;
  if (seconds < 60) {
    return `${seconds.toFixed(2)}s`;
  }
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
}
function generateMarkdownReport(optimizedSelectors, deviceName, timingInfo, projectRoot) {
  const lines = [];
  lines.push("# \u{1F4CA} Mobile Selector Performance Optimizer Report");
  lines.push("");
  if (optimizedSelectors.length === 0) {
    lines.push(`**Device:** ${deviceName}`);
    lines.push(`**Generated:** ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
    lines.push("");
    lines.push("## \u2705 Summary");
    lines.push("");
    lines.push("No optimization opportunities found. All selectors are already optimized!");
    lines.push("");
    return lines.join("\n");
  }
  const usageCounts = countSelectorUsage(optimizedSelectors);
  const deduplicated = deduplicateSelectors(optimizedSelectors, usageCounts);
  const positiveOptimizations = deduplicated.filter((o) => o.improvementMs > 0);
  const negativeOptimizations = deduplicated.filter((o) => o.improvementMs < 0);
  const totalSavingsMs = positiveOptimizations.reduce((sum, o) => sum + o.improvementMs * o.usageCount, 0);
  const avgImprovement = positiveOptimizations.length > 0 ? positiveOptimizations.reduce((sum, o) => sum + o.improvementPercent, 0) / positiveOptimizations.length : 0;
  const highImpact = positiveOptimizations.filter((o) => o.improvementPercent >= 50);
  const mediumImpact = positiveOptimizations.filter((o) => o.improvementPercent >= 20 && o.improvementPercent < 50);
  const lowImpact = positiveOptimizations.filter((o) => o.improvementPercent >= 10 && o.improvementPercent < 20);
  const minorImpact = positiveOptimizations.filter((o) => o.improvementPercent > 0 && o.improvementPercent < 10);
  lines.push(`**Device:** ${deviceName}`);
  if (timingInfo) {
    lines.push(`**Run Time:** ${formatTime(timingInfo.startTime)} \u2192 ${formatTime(timingInfo.endTime)} (${formatDuration(timingInfo.totalRunDurationMs)})`);
  }
  lines.push(`**Analyzed:** ${deduplicated.length} unique selectors (${positiveOptimizations.length} optimizable${negativeOptimizations.length > 0 ? `, ${negativeOptimizations.length} not recommended` : ""})`);
  lines.push("");
  const savingsLine = `**Total Potential Savings:** **${formatDuration(totalSavingsMs)}** per test run`;
  if (timingInfo && timingInfo.totalRunDurationMs > 0) {
    const improvementPercent = totalSavingsMs / timingInfo.totalRunDurationMs * 100;
    lines.push(`${savingsLine} (**${improvementPercent.toFixed(1)}%** of total run time)`);
  } else {
    lines.push(savingsLine);
  }
  lines.push(`**Average Improvement per Selector:** **${avgImprovement.toFixed(1)}%** faster`);
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push("## \u{1F4C8} Summary");
  lines.push("");
  lines.push("| Impact Level | Count | Action |");
  lines.push("|:-------------|------:|:-------|");
  if (highImpact.length > 0) {
    lines.push(`| \u{1F534} **High** (>50% gain) | ${highImpact.length} | Fix immediately |`);
  }
  if (mediumImpact.length > 0) {
    lines.push(`| \u{1F7E0} **Medium** (20-50% gain) | ${mediumImpact.length} | Recommended |`);
  }
  if (lowImpact.length > 0) {
    lines.push(`| \u{1F7E1} **Low** (10-20% gain) | ${lowImpact.length} | Minor optimization |`);
  }
  if (minorImpact.length > 0) {
    lines.push(`| \u26AA **Minor** (<10% gain) | ${minorImpact.length} | Optional |`);
  }
  if (negativeOptimizations.length > 0) {
    lines.push(`| \u26A0\uFE0F **Slower in Testing** | ${negativeOptimizations.length} | See warnings below |`);
  }
  lines.push("");
  lines.push("---");
  lines.push("");
  const { fileGroups, workspaceWide } = groupByFile(positiveOptimizations);
  if (fileGroups.length > 0) {
    lines.push("## \u{1F3AF} File-Based Fixes");
    lines.push("");
    lines.push("*Update these specific lines in your Page Objects or Test files for immediate impact.*");
    lines.push("");
    for (const group of fileGroups) {
      const fileLink = formatFileLink(group.filePath, void 0, projectRoot);
      lines.push(`### \u{1F4C1} ${fileLink}`);
      lines.push("");
      lines.push("| Location | Original | Optimized | Per Use | Uses | Total Saved |");
      lines.push("|:---------|:---------|:----------|--------:|-----:|-----------:|");
      for (const opt of group.optimizations) {
        const original = formatSelector(opt.selector);
        const optimized = formatSelector(opt.optimizedSelector);
        const perUse = `${opt.improvementMs.toFixed(1)}ms`;
        const uses = `${opt.usageCount}\xD7`;
        const totalSaved = `${(opt.improvementMs * opt.usageCount).toFixed(1)}ms`;
        const location = formatLineLink(group.filePath, opt.lineNumber, projectRoot);
        lines.push(`| ${location} | ${original} | ${optimized} | ${perUse} | ${uses} | ${totalSaved} |`);
      }
      lines.push("");
      lines.push(`> **File total:** ${formatDuration(group.totalSavingsWithUsage)} saved (${group.optimizations.length} selector${group.optimizations.length > 1 ? "s" : ""})`);
      lines.push("");
    }
    lines.push("---");
    lines.push("");
  }
  if (workspaceWide.length > 0) {
    lines.push("## \u{1F50D} Workspace-Wide Optimizations");
    lines.push("");
    lines.push("*Source file location unknown. Search your IDE (Cmd+Shift+F / Ctrl+Shift+F) for these selectors.*");
    lines.push("");
    lines.push("| Original | Optimized | Per Use | Uses | Total Saved |");
    lines.push("|:---------|:----------|--------:|-----:|-----------:|");
    for (const opt of workspaceWide) {
      const original = formatSelector(opt.selector);
      const optimized = formatSelector(opt.optimizedSelector);
      const perUse = `${opt.improvementMs.toFixed(1)}ms`;
      const uses = `${opt.usageCount}\xD7`;
      const totalSaved = `${(opt.improvementMs * opt.usageCount).toFixed(1)}ms`;
      lines.push(`| ${original} | ${optimized} | ${perUse} | ${uses} | ${totalSaved} |`);
    }
    lines.push("");
    lines.push("---");
    lines.push("");
  }
  if (negativeOptimizations.length > 0) {
    lines.push("## \u26A0\uFE0F Performance Warnings");
    lines.push("");
    lines.push("*In these cases, the suggested native selector was **slower** than XPath in your test environment. This can happen due to:*");
    lines.push("");
    lines.push("- **App-specific optimizations** - Some apps have optimized XPath handling");
    lines.push("- **Element hierarchy** - Deep nesting can sometimes favor XPath's tree traversal");
    lines.push("- **Caching effects** - First lookups may differ from subsequent ones");
    lines.push("- **Appium/driver version** - Native selector support varies by version");
    lines.push("");
    lines.push("*Recommendation: Keep using XPath for these selectors, or test both approaches in your CI pipeline.*");
    lines.push("");
    lines.push("| Location | XPath (Current) | Suggested Native | XPath Time | Native Time | Result |");
    lines.push("|:---------|:----------------|:-----------------|:-----------|:------------|:-------|");
    for (const opt of negativeOptimizations) {
      const xpathSelector = formatSelector(opt.selector);
      const nativeSelector = formatSelector(opt.optimizedSelector);
      const originalEntry = optimizedSelectors.find((e) => e.selector === opt.selector);
      if (originalEntry) {
        const xpathTime = `${originalEntry.duration.toFixed(0)}ms`;
        const nativeTime = originalEntry.optimizedDuration ? `${originalEntry.optimizedDuration.toFixed(0)}ms` : `${(originalEntry.duration - opt.improvementMs).toFixed(0)}ms`;
        const slowdownMs = Math.abs(opt.improvementMs);
        const slowdownPercent = Math.abs(opt.improvementPercent);
        const result = `Native ${slowdownMs.toFixed(0)}ms slower (${slowdownPercent.toFixed(0)}%)`;
        const location = opt.selectorFile ? formatFileLink(opt.selectorFile, opt.lineNumber, projectRoot) : "*unknown*";
        lines.push(`| ${location} | ${xpathSelector} | ${nativeSelector} | ${xpathTime} | ${nativeTime} | ${result} |`);
      }
    }
    lines.push("");
    lines.push("---");
    lines.push("");
  }
  lines.push("## \u{1F4A1} Implementation Guide");
  lines.push("");
  lines.push("### Why make these changes?");
  lines.push("");
  lines.push("- **Speed:** Native selectors (`~` Accessibility IDs, `-ios predicate string`, `-ios class chain`) bypass expensive XML tree traversal required by XPath");
  lines.push("- **Stability:** Native selectors are less affected by UI hierarchy changes that often break XPath queries");
  lines.push("- **Maintainability:** Shorter, more readable selectors are easier to debug and update");
  lines.push("");
  lines.push("### Selector Priority (fastest to slowest)");
  lines.push("");
  lines.push("1. **Accessibility ID** (`~elementId`) - Direct lookup, fastest");
  lines.push("2. **iOS Predicate String** (`-ios predicate string:...`) - Native predicate evaluation");
  lines.push("3. **iOS Class Chain** (`-ios class chain:...`) - Native hierarchy traversal");
  lines.push("4. **XPath** (`//...`) - Full XML serialization + parsing, slowest");
  lines.push("");
  lines.push("### Resources");
  lines.push("");
  lines.push("- [WebdriverIO Mobile Selectors](https://webdriver.io/docs/selectors#mobile-selectors)");
  lines.push("- [iOS Predicate String](https://webdriver.io/docs/selectors#ios-predicate-string)");
  lines.push("- [iOS Class Chain](https://webdriver.io/docs/selectors#ios-class-chain)");
  lines.push("");
  lines.push("---");
  lines.push("");
  lines.push(`*Generated by WebdriverIO Mobile Selector Performance Optimizer \u2022 ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}*`);
  lines.push("");
  return lines.join("\n");
}

// src/mobileSelectorPerformanceOptimizer/aggregator.ts
function buildInferenceMaps(data) {
  const testFileInference = /* @__PURE__ */ new Map();
  const suiteNameInference = /* @__PURE__ */ new Map();
  for (const entry of data) {
    if (entry.testFile && entry.testFile !== "unknown" && entry.suiteName && entry.suiteName !== "unknown" && entry.testName) {
      const key1 = `${entry.suiteName}::${entry.testName}`;
      if (!testFileInference.has(key1)) {
        testFileInference.set(key1, entry.testFile);
      }
      const key2 = `${entry.testFile}::${entry.testName}`;
      if (!suiteNameInference.has(key2)) {
        suiteNameInference.set(key2, entry.suiteName);
      }
    }
  }
  return { testFileInference, suiteNameInference };
}
function applyInference(testFile, suiteName, testName, inferenceMaps) {
  let resolvedTestFile = testFile;
  let resolvedSuiteName = suiteName;
  if (resolvedTestFile === "unknown" && resolvedSuiteName !== "unknown" && testName !== "unknown") {
    const key = `${resolvedSuiteName}::${testName}`;
    const inferred = inferenceMaps.testFileInference.get(key);
    if (inferred) {
      resolvedTestFile = inferred;
    }
  }
  if (resolvedSuiteName === "unknown" && resolvedTestFile !== "unknown" && testName !== "unknown") {
    const key = `${resolvedTestFile}::${testName}`;
    const inferred = inferenceMaps.suiteNameInference.get(key);
    if (inferred) {
      resolvedSuiteName = inferred;
    }
  }
  return [resolvedTestFile, resolvedSuiteName];
}
function groupDataByDevice(data, capabilities) {
  const deviceMap = /* @__PURE__ */ new Map();
  for (const entry of data) {
    const deviceName = entry.deviceName || "unknown";
    if (!deviceMap.has(deviceName)) {
      deviceMap.set(deviceName, []);
    }
    deviceMap.get(deviceName).push(entry);
  }
  if (deviceMap.size === 1 && deviceMap.has("unknown")) {
    const fallbackDeviceName = getDeviceName(capabilities);
    if (fallbackDeviceName !== "unknown") {
      const unknownData = deviceMap.get("unknown");
      deviceMap.delete("unknown");
      deviceMap.set(fallbackDeviceName, unknownData);
    }
  }
  return deviceMap;
}
async function aggregateSelectorPerformanceData(capabilities, maxLineLength, writeFn, reportDirectory, options) {
  const enableCliReport = options?.enableCliReport === true;
  const enableMarkdownReport = options?.enableMarkdownReport === true;
  const markdownLines = [];
  const cliWrite = writeFn || ((message) => process.stdout.write(message));
  const write = (message) => {
    if (enableCliReport) {
      cliWrite(message);
    }
    if (enableMarkdownReport) {
      markdownLines.push(message);
    }
  };
  const writeError = writeFn || console.error;
  if (!reportDirectory) {
    throw new SevereServiceError2(
      "Mobile Selector Performance Optimizer: Report directory was not determined. This should have been validated during service initialization."
    );
  }
  if (!fs2.existsSync(reportDirectory)) {
    fs2.mkdirSync(reportDirectory, { recursive: true });
  }
  const workersDataDir = path4.join(reportDirectory, "selector-performance-worker-data");
  const timestamp = Date.now();
  try {
    let allData = [];
    if (fs2.existsSync(workersDataDir)) {
      const files = fs2.readdirSync(workersDataDir);
      const workerDataFiles = files.filter((file) => file.startsWith("worker-data-") && file.endsWith(".json"));
      if (workerDataFiles.length > 0) {
        workerDataFiles.forEach((file) => {
          const filePath = path4.join(workersDataDir, file);
          try {
            const content = fs2.readFileSync(filePath, "utf8");
            const workerData = JSON.parse(content);
            if (Array.isArray(workerData)) {
              allData.push(...workerData);
            }
          } catch (err) {
            writeError(`Failed to read worker data file ${file}:`, err);
          }
        });
        try {
          fs2.rmSync(workersDataDir, { recursive: true, force: true });
        } catch {
        }
      }
    }
    if (allData.length === 0) {
      allData = getPerformanceData();
    }
    if (allData.length === 0) {
      return;
    }
    const dataByDevice = groupDataByDevice(allData, capabilities);
    for (const [deviceName, deviceData] of dataByDevice.entries()) {
      const sanitizedDeviceName = deviceName.replace(/[^a-zA-Z0-9-_]/g, "_").toLowerCase() || "unknown";
      const finalJsonPath = path4.join(reportDirectory, `mobile-selector-performance-optimizer-report-${sanitizedDeviceName}-${timestamp}.json`);
      const groupedData = groupDataBySpecFile(deviceData);
      fs2.writeFileSync(finalJsonPath, JSON.stringify(groupedData, null, 2));
      const totalSelectors = deviceData.length;
      const avgDuration = totalSelectors > 0 ? deviceData.reduce((sum, d) => sum + d.duration, 0) / totalSelectors : 0;
      const optimizedSelectors = deviceData.filter((d) => d.optimizedSelector && d.improvementMs !== void 0);
      let timingInfo;
      if (deviceData.length > 0) {
        const timestamps = deviceData.map((d) => d.timestamp).filter((t) => t > 0);
        if (timestamps.length > 0) {
          const startTime = Math.min(...timestamps);
          const endTime = Math.max(...timestamps);
          const totalRunDurationMs = endTime - startTime;
          timingInfo = { startTime, endTime, totalRunDurationMs };
        }
      }
      if (totalSelectors === 0) {
        write("\n\u{1F4CA} Selector Performance Summary:\n");
        write(`${REPORT_INDENT_SUMMARY}No element-finding commands were tracked.
`);
        write(`${REPORT_INDENT_SUMMARY}\u{1F4A1} JSON file written to: ${finalJsonPath}
`);
      } else {
        if (optimizedSelectors.length > 0) {
          generateGroupedSummaryReport(optimizedSelectors, deviceName, write, maxLineLength, timingInfo);
        } else {
          write("\n\u{1F4CA} Selector Performance Summary:\n");
          write(`${REPORT_INDENT_SUMMARY}Total element finds: ${totalSelectors}
`);
          write(`${REPORT_INDENT_SUMMARY}Average duration: ${avgDuration.toFixed(2)}ms
`);
        }
        if (optimizedSelectors.length === 0) {
          write(`
${REPORT_INDENT_SUMMARY}\u2705 All selectors performed well
`);
          write(`${REPORT_INDENT_SUMMARY}\u{1F4A1} JSON file written to: ${finalJsonPath}
`);
        }
      }
      if (enableMarkdownReport) {
        const markdownPath = path4.join(reportDirectory, `mobile-selector-performance-optimizer-report-${sanitizedDeviceName}-${timestamp}.md`);
        const projectRoot = process.cwd();
        const markdownContent = generateMarkdownReport(optimizedSelectors, deviceName, timingInfo, projectRoot);
        fs2.writeFileSync(markdownPath, markdownContent);
        const message = `
\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
\u{1F4DD} Mobile Selector Performance Optimizer - Markdown Report
\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
   \u{1F4C1} Markdown report written to: ${markdownPath}
\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
`;
        console.log(message);
      }
      if (!enableCliReport && !enableMarkdownReport) {
        const message = `
\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
\u{1F4CA} Mobile Selector Performance Optimizer
\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
   \u{1F4C1} JSON report written to: ${finalJsonPath}

   \u{1F4A1} To get actionable optimization advice in your terminal or as a file,
      enable one of these options in your config:

      trackSelectorPerformance: {
          pageObjectPaths: ['./tests/pageobjects'],
          enableCliReport: true,      // Show report in terminal
          enableMarkdownReport: true  // Save report as markdown file
      }
\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
`;
        console.log(message);
      }
    }
  } catch (err) {
    writeError("Failed to aggregate selector performance data:", err);
    if (err instanceof Error) {
      writeError("Error details:", err.message);
    }
  }
}
function groupDataBySpecFile(allData) {
  const inferenceMaps = buildInferenceMaps(allData);
  const processedData = allData.map((data) => {
    const testName = data.testName || "unknown";
    const [testFile, suiteName] = applyInference(
      data.testFile || "unknown",
      data.suiteName || "unknown",
      testName,
      inferenceMaps
    );
    return { ...data, testFile, suiteName };
  });
  const grouped = {};
  for (const data of processedData) {
    const specFile = data.testFile || "unknown";
    let suiteName = data.suiteName || "unknown";
    const testName = data.testName || "unknown";
    if (suiteName === "unknown" && specFile !== "unknown" && testName !== "unknown") {
      const key = `${specFile}::${testName}`;
      const inferred = inferenceMaps.suiteNameInference.get(key);
      if (inferred) {
        suiteName = inferred;
      }
    }
    if (!grouped[specFile]) {
      grouped[specFile] = {};
    }
    if (!grouped[specFile][suiteName]) {
      grouped[specFile][suiteName] = {};
    }
    if (!grouped[specFile][suiteName][testName]) {
      grouped[specFile][suiteName][testName] = [];
    }
    const existing = grouped[specFile][suiteName][testName].find((d) => d.selector === data.selector);
    if (!existing) {
      grouped[specFile][suiteName][testName].push(data);
    }
  }
  for (const specFile of Object.keys(grouped)) {
    const suites = grouped[specFile];
    const suiteNames = Object.keys(suites);
    for (const suiteName of suiteNames) {
      if (suiteName === "unknown") {
        const unknownSuite = suites[suiteName];
        const testNames = Object.keys(unknownSuite);
        for (const testName of testNames) {
          const key = `${specFile}::${testName}`;
          const knownSuiteName = inferenceMaps.suiteNameInference.get(key);
          if (knownSuiteName && suites[knownSuiteName]) {
            if (!suites[knownSuiteName][testName]) {
              suites[knownSuiteName][testName] = [];
            }
            for (const data of unknownSuite[testName]) {
              const existing = suites[knownSuiteName][testName].find((d) => d.selector === data.selector);
              if (!existing) {
                data.suiteName = knownSuiteName;
                suites[knownSuiteName][testName].push(data);
              }
            }
            delete unknownSuite[testName];
          }
        }
        if (Object.keys(unknownSuite).length === 0) {
          delete suites[suiteName];
        }
      }
    }
  }
  for (const specFile of Object.keys(grouped)) {
    const suites = grouped[specFile];
    const sortedSuiteNames = Object.keys(suites).sort((suiteA, suiteB) => {
      const allTimestampsA = [];
      const suiteATests = suites[suiteA];
      for (const testName of Object.keys(suiteATests)) {
        const testData = suiteATests[testName];
        allTimestampsA.push(...testData.map((d) => d.timestamp));
      }
      const allTimestampsB = [];
      const suiteBTests = suites[suiteB];
      for (const testName of Object.keys(suiteBTests)) {
        const testData = suiteBTests[testName];
        allTimestampsB.push(...testData.map((d) => d.timestamp));
      }
      const firstA = allTimestampsA.length > 0 ? Math.min(...allTimestampsA) : 0;
      const firstB = allTimestampsB.length > 0 ? Math.min(...allTimestampsB) : 0;
      return firstA - firstB;
    });
    const sortedSuites = {};
    for (const suiteName of sortedSuiteNames) {
      const tests = suites[suiteName];
      const sortedTestNames = Object.keys(tests).sort((testA, testB) => {
        const firstA = tests[testA].length > 0 ? Math.min(...tests[testA].map((d) => d.timestamp)) : 0;
        const firstB = tests[testB].length > 0 ? Math.min(...tests[testB].map((d) => d.timestamp)) : 0;
        return firstA - firstB;
      });
      const sortedTests = {};
      for (const testName of sortedTestNames) {
        sortedTests[testName] = tests[testName];
      }
      sortedSuites[suiteName] = sortedTests;
    }
    grouped[specFile] = sortedSuites;
  }
  return grouped;
}
function getDeviceName(capabilities) {
  if (!capabilities) {
    return "unknown";
  }
  const extractDeviceName = (caps) => {
    if (!caps || typeof caps !== "object") {
      return void 0;
    }
    const capsRecord = caps;
    const appiumDeviceName = capsRecord["appium:deviceName"];
    if (appiumDeviceName && typeof appiumDeviceName === "string") {
      return appiumDeviceName;
    }
    const w3cCap = caps.alwaysMatch || caps;
    if (w3cCap && typeof w3cCap === "object") {
      const w3cRecord = w3cCap;
      const w3cAppiumDeviceName = w3cRecord["appium:deviceName"];
      if (w3cAppiumDeviceName && typeof w3cAppiumDeviceName === "string") {
        return w3cAppiumDeviceName;
      }
    }
    return void 0;
  };
  if (!Array.isArray(capabilities) && typeof capabilities === "object") {
    const entries = Object.entries(capabilities);
    if (entries.length > 0) {
      const [, firstCap] = entries[0];
      if (firstCap && typeof firstCap === "object") {
        if ("capabilities" in firstCap) {
          const nestedCaps = firstCap.capabilities;
          const deviceName3 = extractDeviceName(nestedCaps);
          if (deviceName3) {
            return deviceName3;
          }
        }
        const deviceName2 = extractDeviceName(firstCap);
        if (deviceName2) {
          return deviceName2;
        }
      }
    }
  }
  if (Array.isArray(capabilities) && capabilities.length > 0) {
    const deviceName2 = extractDeviceName(capabilities[0]);
    if (deviceName2) {
      return deviceName2;
    }
  }
  const deviceName = extractDeviceName(capabilities);
  if (deviceName) {
    return deviceName;
  }
  return "unknown";
}
function wrapLine(line, maxLineLength, indent = "") {
  if (line.length <= maxLineLength) {
    return [line];
  }
  const prefixMatch = line.match(/^(\s*)(\d+\.||)\s+/);
  let continuationIndent = indent;
  if (prefixMatch) {
    const leadingSpaces = prefixMatch[1];
    const prefixMarker = prefixMatch[2];
    continuationIndent = leadingSpaces + " ".repeat(prefixMarker.length + 1);
  } else if (!indent) {
    const leadingWhitespaceMatch = line.match(/^(\s+)/);
    if (leadingWhitespaceMatch) {
      continuationIndent = leadingWhitespaceMatch[1];
    }
  }
  const lines = [];
  let remaining = line;
  let isFirstLine = true;
  while (true) {
    const effectiveMaxLength = isFirstLine ? maxLineLength : maxLineLength - continuationIndent.length;
    if (remaining.length <= effectiveMaxLength) {
      if (remaining.length > 0) {
        if (isFirstLine) {
          lines.push(remaining);
        } else {
          lines.push(continuationIndent + remaining);
        }
      }
      break;
    }
    let breakPoint = effectiveMaxLength;
    const searchStart = Math.max(0, effectiveMaxLength - 20);
    const spaceIndex = remaining.lastIndexOf(" ", effectiveMaxLength);
    const commaIndex = remaining.lastIndexOf(",", effectiveMaxLength);
    const arrowIndex = remaining.lastIndexOf("\u2192", effectiveMaxLength);
    if (arrowIndex > searchStart) {
      breakPoint = arrowIndex + 1;
    } else if (commaIndex > searchStart) {
      breakPoint = commaIndex + 1;
    } else if (spaceIndex > searchStart) {
      breakPoint = spaceIndex + 1;
    }
    if (isFirstLine) {
      const firstLinePart = remaining.substring(0, breakPoint);
      lines.push(firstLinePart);
    } else {
      lines.push(continuationIndent + remaining.substring(0, breakPoint).trim());
    }
    remaining = remaining.substring(breakPoint).trim();
    isFirstLine = false;
  }
  return lines;
}
function countSelectorUsage2(data) {
  const counts = /* @__PURE__ */ new Map();
  for (const entry of data) {
    const count = counts.get(entry.selector) || 0;
    counts.set(entry.selector, count + 1);
  }
  return counts;
}
function deduplicateSelectorsForCli(data, usageCounts) {
  const selectorMap = /* @__PURE__ */ new Map();
  for (const entry of data) {
    if (!entry.optimizedSelector || entry.improvementMs === void 0) {
      continue;
    }
    const existing = selectorMap.get(entry.selector);
    const current = {
      selector: entry.selector,
      optimizedSelector: entry.optimizedSelector,
      improvementMs: entry.improvementMs,
      improvementPercent: entry.improvementPercent || 0,
      lineNumber: entry.lineNumber,
      selectorFile: entry.selectorFile,
      testFile: entry.testFile,
      usageCount: usageCounts.get(entry.selector) || 1,
      duration: entry.duration,
      optimizedDuration: entry.optimizedDuration
    };
    if (!existing || Math.abs(current.improvementMs) > Math.abs(existing.improvementMs)) {
      if (existing && !current.selectorFile && existing.selectorFile) {
        current.selectorFile = existing.selectorFile;
        current.lineNumber = existing.lineNumber;
      }
      selectorMap.set(entry.selector, current);
    } else if (!existing.selectorFile && current.selectorFile) {
      existing.selectorFile = current.selectorFile;
      existing.lineNumber = current.lineNumber;
    }
  }
  return Array.from(selectorMap.values());
}
function groupByFileForCli(optimizations) {
  const fileMap = /* @__PURE__ */ new Map();
  const workspaceWide = [];
  for (const opt of optimizations) {
    const filePath = opt.selectorFile;
    if (filePath && opt.lineNumber) {
      if (!fileMap.has(filePath)) {
        fileMap.set(filePath, []);
      }
      fileMap.get(filePath).push(opt);
    } else {
      workspaceWide.push(opt);
    }
  }
  const fileGroups = [];
  for (const [filePath, opts] of fileMap.entries()) {
    opts.sort((a, b) => (a.lineNumber || 0) - (b.lineNumber || 0));
    const totalSavingsMs = opts.reduce((sum, o) => sum + o.improvementMs, 0);
    const totalSavingsWithUsage = opts.reduce((sum, o) => sum + o.improvementMs * o.usageCount, 0);
    fileGroups.push({ filePath, optimizations: opts, totalSavingsMs, totalSavingsWithUsage });
  }
  fileGroups.sort((a, b) => b.totalSavingsWithUsage - a.totalSavingsWithUsage);
  workspaceWide.sort((a, b) => b.improvementMs * b.usageCount - a.improvementMs * a.usageCount);
  return { fileGroups, workspaceWide };
}
function generateGroupedSummaryReport(optimizedSelectors, deviceName, write, maxLineLength, timingInfo) {
  const usageCounts = countSelectorUsage2(optimizedSelectors);
  const deduplicated = deduplicateSelectorsForCli(optimizedSelectors, usageCounts);
  const positiveOptimizations = deduplicated.filter((o) => o.improvementMs > 0);
  const negativeOptimizations = deduplicated.filter((o) => o.improvementMs < 0);
  if (positiveOptimizations.length === 0 && negativeOptimizations.length === 0) {
    write("\n");
    write("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
    write("\u{1F4CA} Mobile Selector Performance Optimizer\n");
    write("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
    write(`${REPORT_INDENT_SUMMARY}No optimizations found.
`);
    write("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
    return;
  }
  const totalSavingsMs = positiveOptimizations.reduce((sum, o) => sum + o.improvementMs * o.usageCount, 0);
  const avgImprovement = positiveOptimizations.length > 0 ? positiveOptimizations.reduce((sum, o) => sum + o.improvementPercent, 0) / positiveOptimizations.length : 0;
  const highImpact = positiveOptimizations.filter((o) => o.improvementPercent >= 50);
  const mediumImpact = positiveOptimizations.filter((o) => o.improvementPercent >= 20 && o.improvementPercent < 50);
  const lowImpact = positiveOptimizations.filter((o) => o.improvementPercent >= 10 && o.improvementPercent < 20);
  const minorImpact = positiveOptimizations.filter((o) => o.improvementPercent > 0 && o.improvementPercent < 10);
  const { fileGroups, workspaceWide } = groupByFileForCli(positiveOptimizations);
  write("\n");
  write("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
  write("\u{1F4CA} Mobile Selector Performance Optimizer Report\n");
  write("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
  write("\n");
  if (deviceName && deviceName !== "unknown") {
    write(`${REPORT_INDENT_SUMMARY}Device: ${deviceName}
`);
  }
  if (timingInfo) {
    const formatTime2 = (ts) => new Date(ts).toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
    const formatDuration2 = (ms) => {
      if (ms < 1e3) {
        return `${ms.toFixed(0)}ms`;
      }
      const seconds = ms / 1e3;
      if (seconds < 60) {
        return `${seconds.toFixed(2)}s`;
      }
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes}m ${remainingSeconds.toFixed(0)}s`;
    };
    write(`${REPORT_INDENT_SUMMARY}Run Time: ${formatTime2(timingInfo.startTime)} \u2192 ${formatTime2(timingInfo.endTime)} (${formatDuration2(timingInfo.totalRunDurationMs)})
`);
  }
  const analyzedText = negativeOptimizations.length > 0 ? `${deduplicated.length} unique selectors (${positiveOptimizations.length} optimizable, ${negativeOptimizations.length} not recommended)` : `${deduplicated.length} unique selectors (${positiveOptimizations.length} optimizable)`;
  write(`${REPORT_INDENT_SUMMARY}Analyzed: ${analyzedText}
`);
  const formatSavings = (ms) => {
    if (ms < 1e3) {
      return `${ms.toFixed(0)}ms`;
    }
    return `${(ms / 1e3).toFixed(2)}s`;
  };
  let savingsLine = `${REPORT_INDENT_SUMMARY}Total Potential Savings: ${formatSavings(totalSavingsMs)} per test run`;
  if (timingInfo && timingInfo.totalRunDurationMs > 0) {
    const improvementPercent = totalSavingsMs / timingInfo.totalRunDurationMs * 100;
    savingsLine += ` (${improvementPercent.toFixed(1)}% of total run time)`;
  }
  write(`${savingsLine}
`);
  write(`${REPORT_INDENT_SUMMARY}Average Improvement per Selector: ${avgImprovement.toFixed(1)}% faster
`);
  write("\n");
  write("\u{1F4C8} Summary\n");
  write("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n");
  if (highImpact.length > 0) {
    write(`${REPORT_INDENT_SUMMARY}\u{1F534} High (>50% gain):      ${String(highImpact.length).padStart(3)} \u2192 Fix immediately
`);
  }
  if (mediumImpact.length > 0) {
    write(`${REPORT_INDENT_SUMMARY}\u{1F7E0} Medium (20-50% gain):  ${String(mediumImpact.length).padStart(3)} \u2192 Recommended
`);
  }
  if (lowImpact.length > 0) {
    write(`${REPORT_INDENT_SUMMARY}\u{1F7E1} Low (10-20% gain):     ${String(lowImpact.length).padStart(3)} \u2192 Minor optimization
`);
  }
  if (minorImpact.length > 0) {
    write(`${REPORT_INDENT_SUMMARY}\u26AA Minor (<10% gain):     ${String(minorImpact.length).padStart(3)} \u2192 Optional
`);
  }
  if (negativeOptimizations.length > 0) {
    write(`${REPORT_INDENT_SUMMARY}\u26A0\uFE0F  Slower in Testing:    ${String(negativeOptimizations.length).padStart(3)} \u2192 See warnings below
`);
  }
  write("\n");
  if (fileGroups.length > 0) {
    write("\u{1F3AF} File-Based Fixes\n");
    write("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n");
    write(`${REPORT_INDENT_SUMMARY}Update these specific lines for immediate impact:
`);
    write("\n");
    for (const group of fileGroups) {
      write(`${REPORT_INDENT_FILE}\u{1F4C1} ${group.filePath}
`);
      for (const opt of group.optimizations) {
        const formattedOriginal = formatSelectorForDisplay(opt.selector, 45);
        const formattedOptimized = formatSelectorForDisplay(opt.optimizedSelector, 45);
        const quoteStyle = opt.optimizedSelector.startsWith("-ios class chain:") ? "'" : '"';
        const lineNum = opt.lineNumber ? `L${opt.lineNumber}` : "?";
        const perUse = `${opt.improvementMs.toFixed(1)}ms/use`;
        const totalSaved = opt.improvementMs * opt.usageCount;
        const totalDisplay = totalSaved >= 1e3 ? `${(totalSaved / 1e3).toFixed(2)}s` : `${totalSaved.toFixed(1)}ms`;
        if (opt.usageCount > 1) {
          const line = `${REPORT_INDENT_SELECTOR}${lineNum}: $('${formattedOriginal}') \u2192 $(${quoteStyle}${formattedOptimized}${quoteStyle})`;
          const wrapped = wrapLine(line, maxLineLength, REPORT_INDENT_SELECTOR + "    ");
          for (const wrappedLine of wrapped) {
            write(`${wrappedLine}
`);
          }
          write(`${REPORT_INDENT_SELECTOR}    \u26A1 ${perUse} \xD7 ${opt.usageCount} uses = ${totalDisplay} total
`);
        } else {
          const line = `${REPORT_INDENT_SELECTOR}${lineNum}: $('${formattedOriginal}') \u2192 $(${quoteStyle}${formattedOptimized}${quoteStyle}) [${opt.improvementMs.toFixed(1)}ms]`;
          const wrapped = wrapLine(line, maxLineLength, REPORT_INDENT_SELECTOR + "    ");
          for (const wrappedLine of wrapped) {
            write(`${wrappedLine}
`);
          }
        }
      }
      const fileTotalDisplay = group.totalSavingsWithUsage >= 1e3 ? `${(group.totalSavingsWithUsage / 1e3).toFixed(2)}s` : `${group.totalSavingsWithUsage.toFixed(1)}ms`;
      write(`${REPORT_INDENT_SUITE}\u2514\u2500 File total: ${fileTotalDisplay} saved (${group.optimizations.length} selector${group.optimizations.length > 1 ? "s" : ""})
`);
      write("\n");
    }
  }
  if (workspaceWide.length > 0) {
    write("\u{1F50D} Workspace-Wide Optimizations\n");
    write("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n");
    write(`${REPORT_INDENT_SUMMARY}Source file unknown. Search your IDE (Cmd+Shift+F) for these selectors:
`);
    write("\n");
    for (const opt of workspaceWide) {
      const formattedOriginal = formatSelectorForDisplay(opt.selector, 45);
      const formattedOptimized = formatSelectorForDisplay(opt.optimizedSelector, 45);
      const quoteStyle = opt.optimizedSelector.startsWith("-ios class chain:") ? "'" : '"';
      const perUse = `${opt.improvementMs.toFixed(1)}ms/use`;
      const totalSaved = opt.improvementMs * opt.usageCount;
      const totalDisplay = totalSaved >= 1e3 ? `${(totalSaved / 1e3).toFixed(2)}s` : `${totalSaved.toFixed(1)}ms`;
      const line = `${REPORT_INDENT_SELECTOR}$('${formattedOriginal}') \u2192 $(${quoteStyle}${formattedOptimized}${quoteStyle})`;
      const wrapped = wrapLine(line, maxLineLength, REPORT_INDENT_SELECTOR + "  ");
      for (const wrappedLine of wrapped) {
        write(`${wrappedLine}
`);
      }
      if (opt.usageCount > 1) {
        write(`${REPORT_INDENT_SELECTOR}   \u26A1 ${perUse} \xD7 ${opt.usageCount} uses = ${totalDisplay} total
`);
      } else {
        write(`${REPORT_INDENT_SELECTOR}   \u26A1 ${totalDisplay}
`);
      }
    }
    write("\n");
  }
  if (negativeOptimizations.length > 0) {
    write("\u26A0\uFE0F  Performance Warnings\n");
    write("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n");
    write(`${REPORT_INDENT_SUMMARY}Native selectors were SLOWER than XPath for these cases.
`);
    write(`${REPORT_INDENT_SUMMARY}This can happen due to app-specific optimizations, element hierarchy,
`);
    write(`${REPORT_INDENT_SUMMARY}caching effects, or Appium/driver version differences.
`);
    write(`${REPORT_INDENT_SUMMARY}Recommendation: Keep using XPath for these selectors.
`);
    write("\n");
    for (const opt of negativeOptimizations) {
      const xpathSelector = formatSelectorForDisplay(opt.selector, 40);
      const nativeSelector = formatSelectorForDisplay(opt.optimizedSelector, 40);
      const xpathTime = opt.duration ? `${opt.duration.toFixed(0)}ms` : "?";
      const nativeTime = opt.optimizedDuration ? `${opt.optimizedDuration.toFixed(0)}ms` : opt.duration ? `${(opt.duration - opt.improvementMs).toFixed(0)}ms` : "?";
      const slowdownMs = Math.abs(opt.improvementMs).toFixed(0);
      const slowdownPercent = Math.abs(opt.improvementPercent).toFixed(0);
      const location = opt.selectorFile && opt.lineNumber ? `${opt.selectorFile}:${opt.lineNumber}` : opt.selectorFile ? opt.selectorFile : null;
      if (location) {
        write(`${REPORT_INDENT_FILE}\u{1F4CD} ${location}
`);
      }
      write(`${REPORT_INDENT_SELECTOR}XPath:  $('${xpathSelector}') \u2192 ${xpathTime}
`);
      write(`${REPORT_INDENT_SELECTOR}Native: $('${nativeSelector}') \u2192 ${nativeTime}
`);
      write(`${REPORT_INDENT_SELECTOR}        \u274C Native was ${slowdownMs}ms slower (${slowdownPercent}%)
`);
      write("\n");
    }
  }
  write("\u{1F4A1} Why Change?\n");
  write("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n");
  write(`${REPORT_INDENT_SUMMARY}\u2022 Speed: Native selectors bypass expensive XML tree traversal
`);
  write(`${REPORT_INDENT_SUMMARY}\u2022 Stability: Less affected by UI hierarchy changes
`);
  write(`${REPORT_INDENT_SUMMARY}\u2022 Priority: ~accessibilityId > -ios predicate string > -ios class chain > //xpath
`);
  write(`${REPORT_INDENT_SUMMARY}\u2022 Docs: https://webdriver.io/docs/selectors#mobile-selectors
`);
  write("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
}

// src/launcher.ts
var log9 = logger9("@wdio/appium-service");
var DEFAULT_APPIUM_PORT = 4723;
var DEFAULT_LOG_FILENAME = "wdio-appium.log";
var DEFAULT_CONNECTION = {
  protocol: "http",
  hostname: "127.0.0.1",
  path: "/"
};
var APPIUM_START_TIMEOUT = 30 * 1e3;
var AppiumLauncher = class _AppiumLauncher {
  constructor(_options, _capabilities, _config) {
    this._options = _options;
    this._capabilities = _capabilities;
    this._config = _config;
    this._args = {
      basePath: DEFAULT_CONNECTION.path,
      ...this._options.args || {}
    };
    this._logPath = _options.logPath || this._config?.outputDir;
  }
  _logPath;
  _appiumCliArgs = [];
  _args;
  _process;
  _isShuttingDown = false;
  async _getCommand(command) {
    if (!command) {
      command = "node";
      this._appiumCliArgs.unshift(await _AppiumLauncher._getAppiumCommand());
    }
    if (os.platform() === "win32") {
      this._appiumCliArgs.unshift("/c", command);
      command = "cmd";
    }
    return command;
  }
  /**
   * update capability connection options to connect
   * to Appium server
   */
  _setCapabilities(port) {
    let capabilityWasUpdated = false;
    if (!Array.isArray(this._capabilities)) {
      for (const [, capability] of Object.entries(this._capabilities)) {
        const cap = capability.capabilities || capability;
        const c = cap.alwaysMatch || cap;
        if (!isCloudCapability(c) && isAppiumCapability(c)) {
          capabilityWasUpdated = true;
          Object.assign(
            capability,
            DEFAULT_CONNECTION,
            { path: this._args.basePath, port },
            { ...capability }
          );
        }
      }
      return capabilityWasUpdated;
    }
    this._capabilities.forEach((cap) => {
      const w3cCap = cap;
      if (Object.values(cap).length > 0 && Object.values(cap).every((c) => typeof c === "object" && c.capabilities)) {
        Object.values(cap).forEach(
          (c) => {
            const capability = c.capabilities.alwaysMatch || c.capabilities || c;
            if (!isCloudCapability(capability) && isAppiumCapability(capability)) {
              capabilityWasUpdated = true;
              Object.assign(
                c,
                DEFAULT_CONNECTION,
                { path: this._args.basePath, port },
                { ...c }
              );
            }
          }
        );
      } else if (!isCloudCapability(w3cCap.alwaysMatch || cap) && isAppiumCapability(w3cCap.alwaysMatch || cap)) {
        capabilityWasUpdated = true;
        Object.assign(
          cap,
          DEFAULT_CONNECTION,
          { path: this._args.basePath, port },
          { ...cap }
        );
      }
    });
    return capabilityWasUpdated;
  }
  async onPrepare() {
    if (Array.isArray(this._options.args)) {
      throw new Error("Args should be an object");
    }
    this._args.port = typeof this._args.port === "number" ? this._args.port : await getPort({ port: DEFAULT_APPIUM_PORT });
    const capabilityWasUpdated = this._setCapabilities(this._args.port);
    if (!capabilityWasUpdated) {
      log9.warn("Could not identify any capability that indicates a local Appium session, skipping Appium launch");
      return;
    }
    this._appiumCliArgs.push(...formatCliArgs({ ...this._args }));
    const command = await this._getCommand(this._options.command);
    const timeout = this._options.appiumStartTimeout ?? APPIUM_START_TIMEOUT;
    this._process = await this._startAppium(command, this._appiumCliArgs, timeout);
    if (this._logPath) {
      this._redirectLogStream(this._logPath);
    } else {
      log9.info("Appium logs written to stdout");
      this._process.stdout.on("data", this.#logStdout);
      this._process.stderr.on("data", this.#logStderr);
    }
  }
  #logStdout = (data) => {
    log9.debug(data.toString());
  };
  #logStderr = (data) => {
    log9.warn(data.toString());
  };
  promisifiedTreeKill = promisify(treeKill);
  async onComplete(exitCode, config, capabilities) {
    this._isShuttingDown = true;
    const trackConfig = this._options.trackSelectorPerformance;
    if (trackConfig && typeof trackConfig === "object" && !Array.isArray(trackConfig)) {
      try {
        const reportDirectory = determineReportDirectory(
          trackConfig.reportPath,
          this._config,
          this._options
        );
        const maxLineLength = trackConfig.maxLineLength || 100;
        const enableCliReport = trackConfig.enableCliReport === true;
        const enableMarkdownReport = trackConfig.enableMarkdownReport === true;
        await aggregateSelectorPerformanceData(
          capabilities,
          maxLineLength,
          void 0,
          reportDirectory,
          { enableCliReport, enableMarkdownReport }
        );
      } catch (err) {
        log9.error("Failed to aggregate selector performance data:", err);
      }
    }
    if (this._process && this._process.pid) {
      this._process.stdout.off("data", this.#logStdout);
      this._process.stderr.off("data", this.#logStderr);
      log9.info("Killing entire Appium tree");
      try {
        await this.promisifiedTreeKill(this._process.pid, "SIGTERM").catch(async (err) => {
          log9.warn("SIGTERM failed, attempting SIGKILL:", err);
          await this.promisifiedTreeKill(this._process.pid, "SIGKILL");
        });
        log9.info("Process and its children successfully terminated");
      } catch (err) {
        log9.error("Failed to kill Appium process tree:", err);
        try {
          this._process.kill("SIGKILL");
          log9.info("Killed main process directly");
        } catch (e) {
          log9.error("Failed to kill process directly:", e);
        }
      }
    }
  }
  _startAppium(command, args, timeout = APPIUM_START_TIMEOUT) {
    log9.info(`Will spawn Appium process: ${command} ${args.join(" ")}`);
    const appiumEnv = { ...process.env, NODE_OPTIONS: "" };
    const appiumProcess = spawn(command, args, { stdio: ["ignore", "pipe", "pipe"], env: appiumEnv });
    let errorCaptured = false;
    let timeoutId;
    let error;
    return new Promise((resolve3, reject) => {
      let outputBuffer = "";
      timeoutId = setTimeout(() => {
        rejectOnce(new Error("Timeout: Appium did not start within expected time"));
      }, timeout);
      const rejectOnce = (err) => {
        if (!errorCaptured) {
          errorCaptured = true;
          clearTimeout(timeoutId);
          reject(err);
        }
      };
      const onErrorMessage = (data) => {
        const message = data.toString();
        const isDebuggerMessage = message.includes("Debugger attached") || message.includes("Debugger listening on") || message.includes("For help, see: https://nodejs.org/en/docs/inspector");
        if (isDebuggerMessage) {
          return;
        }
        appiumProcess.stderr.off("data", onErrorMessage);
        error = message || "Appium exited without unknown error message";
        const isWarning = message.trim().startsWith("WARN");
        if (isWarning) {
          log9.warn(error);
        } else {
          log9.error(error);
        }
        if (!isWarning) {
          rejectOnce(new Error(error));
        }
      };
      const onStdout = (data) => {
        outputBuffer += data.toString();
        if (outputBuffer.includes("Appium REST http interface listener started")) {
          outputBuffer = "";
          log9.info(`Appium started with ID: ${appiumProcess.pid}`);
          clearTimeout(timeoutId);
          appiumProcess.stdout.off("data", onStdout);
          appiumProcess.stderr.off("data", onErrorMessage);
          resolve3(appiumProcess);
        }
      };
      appiumProcess.stdout.on("data", onStdout);
      appiumProcess.stderr.on("data", onErrorMessage);
      appiumProcess.once("exit", (exitCode) => {
        if (this._isShuttingDown) {
          return;
        }
        let errorMessage = `Appium exited before timeout (exit code: ${exitCode})`;
        if (exitCode === 2) {
          errorMessage += "\n" + (error?.toString() || "Check that you don't already have a running Appium service.");
        } else if (errorCaptured) {
          errorMessage += `
${error?.toString()}`;
        }
        if (exitCode !== 0) {
          log9.error(errorMessage);
        }
        rejectOnce(new Error(errorMessage));
      });
    });
  }
  async _redirectLogStream(logPath) {
    if (!this._process) {
      throw Error("No Appium process to redirect log stream");
    }
    const logFile = getFilePath(logPath, DEFAULT_LOG_FILENAME);
    await fsp.mkdir(path5.dirname(logFile), { recursive: true });
    log9.debug(`Appium logs written to: ${logFile}`);
    const logStream = fs3.createWriteStream(logFile, { flags: "w" });
    this._process.stdout.pipe(logStream);
    this._process.stderr.pipe(logStream);
  }
  static async _getAppiumCommand(command = "appium") {
    try {
      const entryPath = await resolve2(command, import.meta.url);
      return url.fileURLToPath(entryPath);
    } catch (err) {
      const errorMessage = "Appium is not installed locally. Please install via e.g. `npm i --save-dev appium`.\nIf you use globally installed appium please add: `appium: { command: 'appium' }`\nto your wdio.conf.js!\n\n" + err.stack;
      log9.error(errorMessage);
      throw new SevereServiceError3(errorMessage);
    }
  }
};

// src/mobileSelectorPerformanceOptimizer/mspo-service.ts
import crypto from "node:crypto";
import fs4 from "node:fs";
import path6 from "node:path";
import { SevereServiceError as SevereServiceError4 } from "webdriverio";
import logger11 from "@wdio/logger";

// src/mobileSelectorPerformanceOptimizer/mspo-reporter.ts
import WDIOReporter from "@wdio/reporter";
var MobileSelectorPerformanceReporter = class extends WDIOReporter {
  _reportDirectory;
  constructor(options) {
    super({ ...options, stdout: true });
    this._reportDirectory = options.reportDirectory;
  }
  /**
   * Get the current suite from the reporter's suite tracking
   * Returns the most nested suite (skips root suite)
   * Matches spec-reporter approach: uses currentSuites array
   * WDIOReporter base class manages currentSuites - last item is most nested
   */
  getCurrentSuite() {
    if (!this.currentSuites || this.currentSuites.length === 0) {
      return void 0;
    }
    for (let i = this.currentSuites.length - 1; i >= 0; i--) {
      const suite = this.currentSuites[i];
      if (suite.title && suite.title !== "(root)" && suite.title !== "{root}") {
        return suite;
      }
    }
    return void 0;
  }
  /**
   * Update context from current suite (helper to avoid duplication)
   */
  updateContextFromCurrentSuite() {
    const currentSuite = this.getCurrentSuite();
    if (currentSuite) {
      const suiteName = this.extractSuiteName(currentSuite);
      if (suiteName) {
        setCurrentSuiteName(suiteName);
      }
      const testFile = this.extractTestFile(currentSuite);
      if (testFile) {
        setCurrentTestFile(testFile);
      }
    }
  }
  /**
   * Extract test file path from suite, matching spec-reporter logic
   * Spec reporter: suite.file?.replace(process.cwd(), '')
   * Then slices leading '/' when displaying: .slice(1)
   */
  extractTestFile(suite) {
    if (!suite.file) {
      return void 0;
    }
    const testFile = suite.file.replace(process.cwd(), "");
    return testFile.startsWith("/") ? testFile.slice(1) : testFile;
  }
  /**
   * Extract suite name from suite title, matching spec-reporter logic
   * Only skip root suite which has "(root)" title
   */
  extractSuiteName(suite) {
    if (suite.title === "(root)" || suite.title === "{root}") {
      return void 0;
    }
    return suite.title;
  }
  /**
   * Extract test name from test title, matching spec-reporter logic
   * Spec reporter uses test.title directly for all frameworks
   */
  extractTestName(test) {
    return test.title || void 0;
  }
  onSuiteStart(suite) {
    const testFile = this.extractTestFile(suite);
    if (testFile) {
      setCurrentTestFile(testFile);
    }
    if (suite.title && suite.title !== "(root)" && suite.title !== "{root}") {
      setCurrentSuiteName(suite.title);
    }
  }
  onTestStart(test) {
    const testName = this.extractTestName(test);
    if (testName) {
      setCurrentTestName(testName);
    }
    this.updateContextFromCurrentSuite();
  }
  onTestPass(_test) {
  }
  onTestFail(_test) {
  }
  onTestSkip(test) {
    const testName = this.extractTestName(test);
    if (testName) {
      setCurrentTestName(testName);
    }
  }
  onTestPending(test) {
    const testName = this.extractTestName(test);
    if (testName) {
      setCurrentTestName(testName);
    }
  }
  onHookStart() {
    this.updateContextFromCurrentSuite();
  }
  onHookEnd() {
    this.updateContextFromCurrentSuite();
  }
};

// src/mobileSelectorPerformanceOptimizer/optimizer.ts
import logger10 from "@wdio/logger";
var log10 = logger10("@wdio/appium-service:selector-optimizer");
async function optimizeSelector(commandName, selector, originalFunc, browser, options, isMultiple) {
  const elementWord = isMultiple ? "element(s)" : "element";
  const testFile = getCurrentTestFile();
  const locations = findSelectorLocation(testFile, selector, options.pageObjectPaths);
  const locationInfo = formatSelectorLocations(locations);
  log10.info(`[${LOG_PREFIX}: Research Selector] ${commandName}('${formatSelectorForDisplay(selector)}')${locationInfo}`);
  log10.info(`[${LOG_PREFIX}: Step 1] Testing current selector: ${commandName}('${formatSelectorForDisplay(selector)}')`);
  const originalStartTime = getHighResTime();
  const originalResult = await originalFunc.call(browser, selector);
  const originalDuration = getHighResTime() - originalStartTime;
  log10.info(`[${LOG_PREFIX}: Step 1] ${commandName}('${formatSelectorForDisplay(selector)}') took ${originalDuration.toFixed(2)}ms`);
  const conversionResult = await findOptimizedSelector(selector, {
    browser: options.browser
  });
  if (!conversionResult || !conversionResult.selector) {
    if (conversionResult?.warning) {
      log10.warn(`[${LOG_PREFIX}: Warning] ${conversionResult.warning}`);
    }
    if (conversionResult?.suggestion) {
      log10.info(`[${LOG_PREFIX}: Suggestion] Consider using: ${conversionResult.suggestion}`);
    }
    return originalResult;
  }
  const optimizedSelector = conversionResult.selector;
  const quoteStyle = optimizedSelector.startsWith("-ios class chain:") ? "'" : '"';
  log10.info(`[${LOG_PREFIX}: Step 3] Search for a better selector`);
  log10.info(`[${LOG_PREFIX}: Outcome] Potential Optimized Selector: ${commandName}(${quoteStyle}${optimizedSelector}${quoteStyle})`);
  const parsed = parseOptimizedSelector(optimizedSelector);
  if (!parsed) {
    log10.warn(`[${LOG_PREFIX}: Warning] Unknown optimized selector type: ${optimizedSelector}. Using original XPath`);
    return originalResult;
  }
  const isAccessibilityId = parsed.using === "accessibility id";
  if (!isAccessibilityId) {
    log10.debug(`[${LOG_PREFIX}: Debug] Selector type: ${parsed.using}`);
    log10.debug(`[${LOG_PREFIX}: Debug] Selector value: "${parsed.value}"`);
    log10.debug(`[${LOG_PREFIX}: Debug] Starting verification process...`);
  }
  log10.info(`[${LOG_PREFIX}: Step 4] Testing optimized selector: ${commandName}(${quoteStyle}${optimizedSelector}${quoteStyle})`);
  const testResult = await testOptimizedSelector(browser, parsed.using, parsed.value, isMultiple, !isAccessibilityId);
  if (!testResult || testResult.elementRefs.length === 0) {
    log10.warn(`[${LOG_PREFIX}: Warning] Optimized selector '${optimizedSelector}' did not find ${elementWord}, using original XPath`);
    return originalResult;
  }
  const foundMessage = isMultiple ? `Optimized selector found ${testResult.elementRefs.length} element(s) in ${testResult.duration.toFixed(2)}ms` : `Optimized selector found element in ${testResult.duration.toFixed(2)}ms`;
  log10.info(`[${LOG_PREFIX}: Step 4] ${foundMessage}`);
  const timeDifference = originalDuration - testResult.duration;
  const improvementPercent = originalDuration > 0 ? timeDifference / originalDuration * 100 : 0;
  const testContext = {
    testFile: getCurrentTestFile() || "unknown",
    suiteName: getCurrentSuiteName() || "unknown",
    testName: getCurrentTestName() || "unknown",
    lineNumber: locations.length > 0 ? locations[0].line : void 0,
    selectorFile: locations.length > 0 ? locations[0].file : void 0
  };
  const optimizedData = createOptimizedSelectorData(
    testContext,
    selector,
    originalDuration,
    optimizedSelector,
    testResult.duration
  );
  addPerformanceData(optimizedData);
  logOptimizationConclusion(timeDifference, improvementPercent, selector, optimizedSelector, locationInfo);
  options.isReplacingSelector.value = true;
  try {
    return await originalFunc.call(browser, optimizedSelector);
  } finally {
    options.isReplacingSelector.value = false;
  }
}
async function optimizeSingleSelector(commandName, selector, originalFunc, browser, options) {
  return optimizeSelector(commandName, selector, originalFunc, browser, options, false);
}
async function optimizeMultipleSelectors(commandName, selector, originalFunc, browser, options) {
  return optimizeSelector(commandName, selector, originalFunc, browser, options, true);
}

// src/mobileSelectorPerformanceOptimizer/overwrite.ts
function overwriteUserCommands(browser, options) {
  if (!("overwriteCommand" in browser && typeof browser.overwriteCommand === "function")) {
    return;
  }
  const browserWithOverwrite = browser;
  for (const commandName of SINGLE_ELEMENT_COMMANDS) {
    browserWithOverwrite.overwriteCommand(commandName, async (originalFunc, selector) => {
      if (options.isReplacingSelector.value || !isNativeContext(browser) || !isXPathSelector(selector)) {
        return originalFunc.call(browser, selector);
      }
      return optimizeSingleSelector(commandName, selector, originalFunc, browser, options);
    });
  }
  for (const commandName of MULTIPLE_ELEMENT_COMMANDS) {
    browserWithOverwrite.overwriteCommand(commandName, async (originalFunc, selector) => {
      if (options.isReplacingSelector.value || !isNativeContext(browser) || !isXPathSelector(selector)) {
        return originalFunc.call(browser, selector);
      }
      return optimizeMultipleSelectors(commandName, selector, originalFunc, browser, options);
    });
  }
}

// src/mobileSelectorPerformanceOptimizer/mspo-service.ts
var log11 = logger11("@wdio/appium-service:selector-optimizer");
var SelectorPerformanceService = class {
  constructor(_options, _config) {
    this._options = _options;
    this._config = _config;
    const trackConfig = _options.trackSelectorPerformance;
    if (trackConfig !== void 0 && trackConfig !== null) {
      if (typeof trackConfig !== "object" || Array.isArray(trackConfig)) {
        throw new SevereServiceError4(
          "trackSelectorPerformance must be an object. Expected format: { pageObjectPaths: string[], enableCliReport?: boolean, enableMarkdownReport?: boolean, reportPath?: string, maxLineLength?: number }"
        );
      }
      if (!trackConfig.pageObjectPaths || trackConfig.pageObjectPaths.length === 0) {
        throw new SevereServiceError4(
          "trackSelectorPerformance.pageObjectPaths is required. Please provide an array of paths to directories containing page objects or test files where selectors are defined. Example: pageObjectPaths: ['./tests/pageobjects']"
        );
      }
      this._enabled = true;
      this._pageObjectPaths = trackConfig.pageObjectPaths;
      this._enableCliReport = trackConfig.enableCliReport === true;
      this._enableMarkdownReport = trackConfig.enableMarkdownReport === true;
      this._reportDirectory = determineReportDirectory(
        trackConfig.reportPath,
        this._config,
        this._options
      );
    }
  }
  // Service configuration
  _enabled = false;
  _enableCliReport = false;
  _enableMarkdownReport = false;
  _reportDirectory;
  _pageObjectPaths = [];
  // Some internal consts
  _browser;
  _isReplacingSelectorRef = { value: false };
  _commandTimings = /* @__PURE__ */ new Map();
  // User commands to track
  _userCommands = new Set(USER_COMMANDS);
  // Internal commands to not track
  _internalCommands = /* @__PURE__ */ new Set([
    "findElement",
    "findElements"
  ]);
  async beforeSession(config, _capabilities, _specs) {
    if (this._enabled && config) {
      if (!config.reporters) {
        config.reporters = [];
      }
      const isAlreadyRegistered = isReporterRegistered(config.reporters, "MobileSelectorPerformanceReporter");
      if (!isAlreadyRegistered) {
        const reporterOptions = {
          reportDirectory: this._reportDirectory
        };
        const reporterEntry = [MobileSelectorPerformanceReporter, reporterOptions];
        config.reporters.push(reporterEntry);
      }
    }
  }
  async before(_capabilities, _specs, browser) {
    this._browser = browser;
    if (this._enabled) {
      log11.info("Mobile Selector Performance Optimizer (BETA)");
      log11.info("   \u2192 All feedback is welcome!");
      log11.info("   \u2192 Currently optimized for iOS (shows the most significant performance and stability gains)");
      if (this._browser.isAndroid) {
        log11.info("Mobile Selector Performance Optimizer is disabled for Android");
        log11.info("   \u2192 Android support coming in a future release");
        this._enabled = false;
        return;
      }
      const deviceName = this._extractDeviceName(browser);
      if (deviceName) {
        setCurrentDeviceName(deviceName);
        log11.debug(`Device name stored: ${deviceName}`);
      }
      log11.info("Mobile Selector Performance Optimizer enabled for iOS");
    }
    if (this._enabled) {
      overwriteUserCommands(browser, {
        browser,
        isReplacingSelector: this._isReplacingSelectorRef,
        pageObjectPaths: this._pageObjectPaths
      });
    }
  }
  async beforeCommand(commandName, args) {
    if (!this._enabled) {
      return;
    }
    if (!isNativeContext(this._browser)) {
      log11.info("Mobile Selector Performance Optimizer is disabled for non-native context");
      return;
    }
    if (this._userCommands.has(commandName)) {
      const selector = extractSelectorFromArgs(args);
      if (!selector || typeof selector !== "string") {
        return;
      }
      const formattedSelector = formatSelectorForDisplay(selector);
      const timingId = crypto.randomUUID();
      const testFile = getCurrentTestFile();
      const locations = findSelectorLocation(testFile, selector, this._pageObjectPaths);
      const lineNumber = locations.length > 0 ? locations[0].line : void 0;
      this._commandTimings.set(timingId, {
        startTime: getHighResTime(),
        commandName,
        selector,
        formattedSelector,
        timingId,
        isUserCommand: true,
        lineNumber
      });
      return;
    }
    if (this._internalCommands.has(commandName)) {
      if (!args || args.length < 2) {
        return;
      }
      const using = args[0];
      const value = args[1];
      if (using !== "xpath" || !value || typeof value !== "string") {
        return;
      }
      const formattedSelector = formatSelectorForDisplay(value);
      const matchingUserCommand = findMostRecentUnmatchedUserCommand(this._commandTimings);
      if (matchingUserCommand) {
        const [, userTiming] = matchingUserCommand;
        userTiming.selectorType = using;
        const timingId = crypto.randomUUID();
        this._commandTimings.set(timingId, {
          startTime: getHighResTime(),
          commandName: userTiming.commandName,
          selector: value,
          formattedSelector,
          selectorType: using,
          timingId,
          isUserCommand: false,
          lineNumber: userTiming.lineNumber
        });
      }
    }
  }
  async afterCommand(commandName, args, _result, _error) {
    if (!this._enabled) {
      return;
    }
    if (!isNativeContext(this._browser)) {
      log11.info("Mobile Selector Performance Optimizer is disabled for non-native context");
      return;
    }
    if (this._internalCommands.has(commandName)) {
      if (!args || args.length < 2) {
        return;
      }
      const using = args[0];
      const value = args[1];
      if (using !== "xpath" || !value || typeof value !== "string") {
        return;
      }
      const formattedSelector = formatSelectorForDisplay(value);
      const matchingTiming = findMatchingInternalCommandTiming(this._commandTimings, formattedSelector, using);
      if (!matchingTiming) {
        return;
      }
      const [timingId, timing] = matchingTiming;
      const duration = getHighResTime() - timing.startTime;
      if (duration < 0 || !timing.selector || !timing.selectorType) {
        this._commandTimings.delete(timingId);
        return;
      }
      const testContext = {
        testFile: getCurrentTestFile() || "unknown",
        suiteName: getCurrentSuiteName() || "unknown",
        testName: getCurrentTestName() || "unknown",
        lineNumber: timing.lineNumber
      };
      storePerformanceData(timing, duration, testContext);
      this._commandTimings.delete(timingId);
    }
  }
  async afterSession() {
    if (!this._enabled) {
      return;
    }
    if (!this._reportDirectory) {
      log11.warn("Report directory not set, cannot write worker selector performance data");
      return;
    }
    const workersDataDir = path6.join(this._reportDirectory, "selector-performance-worker-data");
    const workerDataPath = path6.join(workersDataDir, `worker-data-${process.pid}.json`);
    try {
      const performanceData2 = getPerformanceData();
      fs4.mkdirSync(workersDataDir, { recursive: true });
      fs4.writeFileSync(workerDataPath, JSON.stringify(performanceData2, null, 2));
      log11.debug(`Worker selector performance data written to: ${workerDataPath} (${performanceData2.length} entries)`);
    } catch (err) {
      log11.error("Failed to write worker selector performance data:", err);
    }
  }
  /**
   * Extract device name from browser capabilities
   */
  _extractDeviceName(browser) {
    if (!browser || !("capabilities" in browser)) {
      return void 0;
    }
    const caps = browser.capabilities;
    if (caps["appium:deviceName"] && typeof caps["appium:deviceName"] === "string") {
      return caps["appium:deviceName"];
    }
    return void 0;
  }
};

// src/index.ts
var AppiumService = class extends SelectorPerformanceService {
};
var launcher = AppiumLauncher;
export {
  AppiumService as default,
  launcher
};
